[{"content":"","date":"2023-09-07","id":0,"permalink":"/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"","date":"0001-01-01","id":1,"permalink":"/docs/how-to-guides/","summary":"","tags":[],"title":"How-to Guides"},{"content":"","date":"2023-09-07","id":2,"permalink":"/docs/troubleshooting/","summary":"","tags":[],"title":"Troubleshooting"},{"content":"Test ","date":"2023-09-07","id":3,"permalink":"/docs/faq/","summary":"Test ","tags":[],"title":"FAQ"},{"content":"","date":"2023-09-07","id":4,"permalink":"/docs/references/","summary":"","tags":[],"title":"References"},{"content":"Overview ENBUILD is a cutting-edge software development and engineering tool designed to simplify the complexities of modern-day DevSecOps, containerization and cloud tooling. At its core, ENBUILD offers a self-service catalog featuring pre-packaged templates known as ENBUILD Catalog Items. These templates encompass Terraform Infrastructure deployments on major cloud platforms (AWS, Azure, GCP) and Helm Deployments onto Kubernetes, providing developers with a robust foundation for both infrastructure and application deployment. With automated GitLab and GitHub workflows and pipelines, ENBUILD streamlines the deployment process, allowing developers to focus on value-added work.\nThis tool is specifically tailored for the United States Department of Defense and Government Organizations embarking on DevSecOps Transformation, Cloud Migration, or Platform Development journeys. ENBUILD serves as a strategic accelerator for the adoption of the United States Air Force\u0026rsquo;s Platform One Big Bang Tech Stack, enabling rapid and secure software development and deployment. With seamless integration into popular Continuous Integration / Continuous Deployment engines like GitLab and GitHub, ENBUILD ensures a unified development lifecycle. Moreover, its integration with identity and access management solutions, including Keycloak and Okta, ensures compliance with government regulations through robust Role-Based Access Control (RBAC).\nAs a Kubernetes-native deployment, ENBUILD provides versatility across various Kubernetes environments, supporting AWS EKS, Azure AKS, Rancher, OpenShift, and more. By abstracting toil work and complexities, ENBUILD aims to meet 60-70% of developers\u0026rsquo; needs out of the box, offering a solid starting point for customization and specialization. In summary, ENBUILD stands as a comprehensive solution, empowering organizations to enhance their development processes, accelerate cloud adoption, and navigate the challenges of modern software engineering and infrastructure deployment with ease.\n","date":"2023-09-07","id":5,"permalink":"/docs/getting-started/introduction/","summary":"Overview ENBUILD is a cutting-edge software development and engineering tool designed to simplify the complexities of modern-day DevSecOps, containerization and cloud tooling.","tags":[],"title":"Introduction"},{"content":"\nENBUILD addresses the challenges associated with Day 1 installation and configuration of a Big Bang Kubernetes cluster, offering a streamlined approach for Day 2 operations, including platform upgrades and automation tool patches.\nEase of Use: ENBUILD simplifies Big Bang deployments through a user-friendly UI that facilitates the selection and configuration of DevSecOps pipeline tools. It alleviates common pain points, such as secrets creation and Helm configurations, by utilizing pre-created templates.\nFaster Deployment and Continuous ATO: ENBUILD significantly reduces deployment times, enabling organizations to deploy Big Bang in days rather than weeks or months. It expedites approval processes by leveraging Iron Bank accredited containers.\nOn-Premise \u0026amp; Multi-Cloud Support: ENBUILD provides flexibility by supporting on-premise and cloud deployments across various environments, from edge to commercial Clouds, government Clouds, and air-gapped environments. It allows the deployment of Big Bang stacks on AWS and Azure GovCloud, showcasing cloud-agnostic components.\nOut of the Box Security: Built on pre-hardened DISA compliant containers from Iron Bank, ENBUILD ensures robust security. It incorporates built-in GitOps and Secrets Management for enterprise-grade deployments.\nPre-Built Catalog of Solutions: ENBUILD offers a pre-built catalog featuring solutions for AI/ML deployments using KubeFlow, secure Cloud Computing Architecture based Landing Zones, and data ingestion stacks using Nifi/Kafka/Spark.\nNo Vendor Lock-in: ENBUILD serves as a service delivery accelerator without licensing fees, promoting cost efficiency. It relies on open-source components, fostering a vendor-agnostic approach for greater flexibility and adaptability.\n","date":"2023-09-07","id":6,"permalink":"/docs/getting-started/why-enbuild/","summary":"ENBUILD addresses the challenges associated with Day 1 installation and configuration of a Big Bang Kubernetes cluster, offering a streamlined approach for Day 2 operations, including platform upgrades and automation tool patches.","tags":[],"title":"Why ENBUILD"},{"content":"\nVivSoft is a diverse team of strategists, engineers, designers, and builders\nWHAT WE DO We solve complex organizational challenges, balancing cutting-edge technology with a deep sense of empathy and understanding. We build secure Software Factories based on DoD reference designs and NIST guidelines for Cloud and DevSecOps. These factories deliver AI/ML Applications, Data Science Platforms, Blockchain and Microservices for DoD, Healthcare and Civilian Agencies. ","date":"0001-01-01","id":7,"permalink":"/docs/getting-started/about-vivsoft/","summary":"VivSoft is a diverse team of strategists, engineers, designers, and builders\nWHAT WE DO We solve complex organizational challenges, balancing cutting-edge technology with a deep sense of empathy and understanding.","tags":[],"title":"About Vivsoft"},{"content":"ENBUILD operates as a bridge between developers and the Continuous Integration/Continuous Deployment (CI/CD) systems, specifically with popular platforms like GitHub and GitLab. This tool simplifies the entire software development process, making it accessible and efficient for users with various technical backgrounds.\nGitHub Integration When working with GitHub, ENBUILD seamlessly communicates with the CI/CD provider through REST and GraphQL APIs. It starts by creating a Repository Project, essentially a structured workspace, using a template repository project. The user interacts with ENBUILD through an intuitive user interface (UI), providing inputs that guide the customization of files. These files are then updated based on the user\u0026rsquo;s preferences. Once the configuration is complete, ENBUILD executes the predefined workflow or pipeline, automating the deployment process without the need for intricate manual steps.\nGitLab Integration Similarly, when integrating with GitLab, ENBUILD initiates the process by creating a Repository Project within the GitLab environment. Just like with GitHub, the user\u0026rsquo;s inputs through the ENBUILD UI guide the customization of files within the project. ENBUILD updates these files accordingly, ensuring that the project aligns with the user\u0026rsquo;s specifications. Subsequently, the tool triggers the execution of the workflow or pipeline, seamlessly automating the development and deployment steps.\nIn essence, ENBUILD acts as a facilitator, taking the complexities out of setting up projects and workflows. It empowers users to customize their development environments through a straightforward UI, enabling a smooth and efficient interaction with CI/CD systems like GitHub and GitLab. The result is an accelerated and simplified software development process, allowing developers to focus on building innovative solutions without getting bogged down by technical intricacies.\n","date":"2023-09-07","id":8,"permalink":"/docs/getting-started/how-enbuild-works/","summary":"ENBUILD operates as a bridge between developers and the Continuous Integration/Continuous Deployment (CI/CD) systems, specifically with popular platforms like GitHub and GitLab.","tags":[],"title":"How ENBUILD works"},{"content":"Architecture Digram Frontend Service The ENBUILD frontend service provides the ENBUILD User Interface (UI) to the end user.\nBackend Service The ENBUILD backend service is responsible for integration with the CI/CD Provider.\nUser Service The ENBUILD user service manages the end-user\u0026rsquo;s state, such as authentication, access, API access and role-based access control.\nML Service The ENBUILD ML (Machine Learning) service enables data scientists to quickly create feature sets and deploy models. An instance of Jupyter Notebook can also be created and accessed from this service. (This is a placeholder service for demo purposes for now and will be implemented in the future)\nRequest Service The ENBUILD Request service is demo service to enable linking multiple catalog items to one another and deploy them together. (This is a placeholder service for demo purposes for now and will be implemented in the future)\nRabbitMQ Consumer Service The ENBUILD RabbitMQ consumer service processes jobs in the work queue as well as integrates with the CI/CD Provider APIs.\nNoSQL Database ENBUILD utilizes a NoSQL database to manage the application’s state across all microservices. ENBUILD provides a MongoDB instance out-of-the-box, but also can integrate with Cloud Service Provider NoSQL Databases such as Azure’s CosmosDB and AWS’ DocumentDB.\nIdentity and Access Management ENBUILD supports integration with Okta and Keycloak. Keycloak can act as an Identity Broker for other IdAM products such as Active Directory.\n","date":"2023-09-07","id":9,"permalink":"/docs/getting-started/enbuild-architecture/","summary":"Architecture Digram Frontend Service The ENBUILD frontend service provides the ENBUILD User Interface (UI) to the end user.\nBackend Service The ENBUILD backend service is responsible for integration with the CI/CD Provider.","tags":[],"title":"ENBUILD Architecture"},{"content":"Home Page / Catalogs page Stack List Page Manage Catalog page This page needs admin permission\nBuild ML This page is only visible if the Build ML flag is enabled in the feature flag.\nBuild GenAI This page is only visible if the Build GenAI flag is enabled in the feature flag.\nOperations This page is only visible if the operations flag is enabled in the feature flag.\nMetrics These are the quick metrices Logs These are the logs for your cluster where enbuild is deployed. View Deployment Logs Click on a deployment to view its logs. Create a new deployment Create a new deployment by clicking on the \u0026ldquo;New Deployment\u0026rdquo; button. Settings This page allows you to configure various settings for ENBUILD. ","date":"0001-01-01","id":10,"permalink":"/docs/getting-started/enbuild-ui-walkthrough/","summary":"Home Page / Catalogs page Stack List Page Manage Catalog page This page needs admin permission\nBuild ML This page is only visible if the Build ML flag is enabled in the feature flag.","tags":[],"title":"ENBUILD UI walkthrough"},{"content":"ENBUILD Helm Chart Values The following key value pairs are used to configure ENBUILD.\nParameters Global parameters Name Description Value global.AppVersion [default: \u0026ldquo;\u0026rdquo;] Provide custom appVersion, to override the default one. All the ENBUILD images will be of the same version. To use indidual tag for each service set the tag on per service basis. \u0026quot;\u0026quot; global.domain What domain to use to expose the ENBUILD using istio or Ingress ijuned.com global.disable_tls_gitlab Set to true if you are using self-signed certificates false global.ingress.enabled Should we create the Ingress Resources ? false global.ingress.tls Is Ingress TLS enabled ? false global.ingress.tls_secret If Ingress is TLS enabled, Provide the Secret for the TLS Certificate. \u0026quot;\u0026quot; global.ingress.classname Ingress classname if enabled. \u0026quot;\u0026quot; global.ingress.annotations Ingress annotations if enabled. [] global.istio.enabled Should we create the Istio Resources ? false global.istio.gateway Istio gateway to use for creating Virtual Service. istio-system/main Container Registry Parameters Name Description Value imageCredentials Should we use a private container registry? if yes provide the following parameters {} imageCredentials.registry Container registry Path \u0026quot;\u0026quot; imageCredentials.username Container registry Username \u0026quot;\u0026quot; imageCredentials.password Container registry password \u0026quot;\u0026quot; Jupyterhub Parameters Name Description Value jupyterhub.cull.enabled Deploy Jupyterhub false ENBUILD RabbitMQ parameters Name Description Value rabbitmq.enabled Set to false to use existing RabbitMQ true rabbitmq.replicaCount RabbitMQ replicaCount 1 rabbitmq.auth.username RabbitMQ username admin rabbitmq.auth.password RabbitMQ password SuperSecret rabbitmq.auth.erlangCookie RabbitMQ erlangCookie lamba rabbitmq.host If rabbitmq.enabled is false , provide the right rabbitmq endpoint \u0026quot;\u0026quot; rabbitmq.queue_prefix Queue Prefix for all RabbitMQ Queues enbuild ENBUILD Backend/DB parameters Name Description Value mongodb.enabled Set to true to Deploy the MongoDB. false mongodb.mongo_root_username DB username. If mongodb.enabled this is used to to set the username. Else this is username for existing Cosmos or DocumentDB \u0026quot;\u0026quot; mongodb.mongo_root_password DB Password. If mongodb.enabled this is used to to set the password. Else this is password for existing Cosmos or DocumentDB \u0026quot;\u0026quot; mongodb.mongo_server If mongodb.enabled is false , provide the right cosmosDB/DocumentDB endpoint \u0026quot;\u0026quot; mongodb.image.repository Container repository for mongodb Container registry.gitlab.com/enbuild-staging/container_registry/opensource-mongodb/mongodb mongodb.image.tag Container tag for mongodb Container 4.4.5 mongodb.image.pullPolicy Container ImagePullPolicy for mongodb Container Always ENBUILD UI Services parameters Name Description Value enbuildUi.image.repository Container repository for enbuildUi registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-frontend enbuildUi.image.pullPolicy Container image pullPolicy Always enbuildUi.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildUi.replicas Container enbuildUI Replicas 1 enbuildUi.service_type enbuildUI service_type ClusterIP enbuildUi.node_port enbuildUI node_port 30080 enbuildUi.hostname enbuild service hostname. enbuildUi.hostname.global.domain becomes your FQDN enbuild enbuildUi.kiali_url kiali_url https://kiali.ijuned.com/kiali/ enbuildUi.grafana_url grafana_url https://grafana.ijuned.com/ enbuildUi.loki_url loki_url https://grafana.ijuned.com/d/liz0yRCZz/logs-app?orgId=1 enbuildUi.kubecost_url kubecost_url https://kubecost.ijuned.com/overview.html ENBUILD Backend Services parameters Name Description Value enbuildBk.image.repository Container repository for enbuildBk registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-backend enbuildBk.image.pullPolicy Container image pullPolicy Always enbuildBk.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildBk.replicas Container enbuildBk Replicas 1 enbuildBk.service_type enbuildBk service_type ClusterIP enbuildBk.encryption_key encryption_key to be used by Backend encryption_key ENBUILD USER Services parameters Name Description Value enbuildUser.image.repository Container repository for enbuildUser registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-user enbuildUser.image.pullPolicy Container image pullPolicy Always enbuildUser.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildUser.replicas Container enbuildUser Replicas 1 enbuildUser.service_type enbuildUser service_type ClusterIP ENBUILD Sync Services parameters Name Description Value enbuildSync.image.repository Container repository for enbuildSync registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-cronjob enbuildSync.image.pullPolicy Container image pullPolicy Always enbuildSync.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildSync.replicas Container enbuildSync Replicas 1 ENBUILD ML Services parameters Name Description Value enbuildMl.enabled Should we create the ENBUILD ML microservice ? false enbuildMl.image.repository Container repository for enbuildMl registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-ml enbuildMl.image.pullPolicy Container image pullPolicy Always enbuildMl.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildMl.replicas Container enbuildMl Replicas 1 enbuildMl.service_type enbuildMl service_type ClusterIP ENBUILD GenAI Services parameters Name Description Value enbuildGenAI.enabled Should we create the ENBUILD GenAI microservice ? false enbuildGenAI.image.repository Container repository for enbuildGenAI registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-genai enbuildGenAI.image.pullPolicy Container image pullPolicy Always enbuildGenAI.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildGenAI.replicas Container enbuildGenAI Replicas 1 enbuildGenAI.service_type enbuildGenAI service_type ClusterIP enbuildGenAI.api_key api_key for OpenAI service. dummy ENBUILD Request Services parameters Name Description Value enbuildRequest.enabled Should we create the ENBUILD Request microservice ? false enbuildRequest.image.repository Container repository for enbuildRequest registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-request enbuildRequest.image.pullPolicy Container image pullPolicy Always enbuildRequest.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildRequest.replicas Container enbuildRequest Replicas 1 enbuildRequest.service_type enbuildRequest service_type ClusterIP ","date":"0001-01-01","id":11,"permalink":"/docs/getting-started/helm-values/","summary":"ENBUILD Helm Chart Values The following key value pairs are used to configure ENBUILD.\nParameters Global parameters Name Description Value global.","tags":[],"title":"Helm Values"},{"content":"GitLab Resources The following table contains groups and repositories for ENBUILD.\nName Description iac-templates All ENBUILD Catalog Item Templates are located in this Group. vivsoft-platform The vivsoft-platform repository contains the source code for ENBUILD microservices. It is the codebase for building and maintaining the various microservices that collectively form the ENBUILD platform. baseos-rhel8 The basewos-rhel8 repository includes Packer configuration for creating a Red Hat 8 hardened Amazon Machine Image (AMI). It provides the necessary settings and scripts to build a secure and minimal RHEL8 AMI for ENBUILD use. enbuild-packer-rhel8 The enbuild-packer-rhel8 repository contains Packer configuration specifically tailored for creating a minimal ENBUILD AMI. It includes the necessary configuration details for building a lightweight and optimized AMI. hardened-gitlab-runner The hardened-gitlab-runner repository provides Dockerfile configuration for building a GitLab Runner container image with enhanced security measures. It is designed to create a secure environment for CI/CD processes within the ENBUILD ecosystem. enbuild-helm-chart The enbuild-helm-chart repository contains the Helm Chart for deploying ENBUILD. It provides the necessary configurations and definitions for using Helm to deploy and manage ENBUILD components in a Kubernetes environment. GitHub Resources The following table contains groups and repositories for ENBUILD.\nHere\u0026rsquo;s your markdown table for the provided data:\nName Description VivSoftOrg VivSoftOrg is an organizational group that houses all ENBUILD Catalog Item Templates. It serves as a centralized repository for various templates related to ENBUILD. The table includes the Name as a hyperlink directing to the corresponding link and provides a description alongside it.\n","date":"0001-01-01","id":12,"permalink":"/docs/getting-started/enbuild-repositories/","summary":"GitLab Resources The following table contains groups and repositories for ENBUILD.\nName Description iac-templates All ENBUILD Catalog Item Templates are located in this Group.","tags":[],"title":"ENBUILD Repositories"},{"content":"Follow these step-by-step instructions to deploy ENBUILD locally for testing.\nPrerequisites Existing Kubernetes Cluster Ensure that you have access to a Kubernetes cluster and obtain the KubeConfig file.\nYou can use rancher-desktop or k3d to spin up a local Kubernetes cluster.\nENBUILD Container Images Access to the ENBUILD container images are required for this deployment. These images are published to the VivSoft managed container reigistry on registry.gitLab.com. Make sure that you have the necessary credentials to pull these images.\nHelm CLI The Helm streamlines and automates Kubernetes deployments by managing charts, enabling users to easily package, version, and deploy complex applications.\nDeployment Steps: Following are the steps you will need to take to deploy ENBUILD to your Kubernetes cluster.\nAdd ENBUILD Helm Chart Repository To add the ENBUILD Helm chart repository, run the following command:\nhelm repo add vivsoft https://vivsoftorg.github.io/enbuild \u0026#34;vivsoft\u0026#34; has been added to your repositories Configure ENBUILD Helm Values Before deploying ENBUILD to the Kubernetes cluster, you will need to create a custom values.yaml file so that we can specify configurations unique to this deployment.\nFor local deployment however we require minimum deployment values.\n❗ Note: For more information about the complete set of ENBUILD Helm values click here!\nglobal: imageCredentials: registry: registry.gitlab.com username: MY_GITLAB_USERNAME password: MY_GITLAB_TOKEN ⚡ Note: The imageCredentials section is only required until the images are available publically.\nDeploy ENBUILD HELM Chart Make sure you update the values input to reference the values you created in Step 2. Execute the command below.\nhelm upgrade --install --namespace enbuild enbuild vivsoft/enbuild --create-namespace -f target/quick_install.yaml Release \u0026#34;enbuild\u0026#34; does not exist. Installing it now. NAME: enbuild LAST DEPLOYED: Fri Mar 22 17:37:23 2024 NAMESPACE: enbuild STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: 1. Get the application URL by running these commands: echo \u0026#34;Visit http://127.0.0.1:3000 to use your application after starting the port forward\u0026#34; kubectl --namespace enbuild port-forward svc/enbuild-enbuild-ui 3000:80 Validate ENBUILD Deployment Use the following commands to validate the ENBUILD pods are up and running.\nkubectl get pods -n enbuild NAME READY STATUS RESTARTS AGE enbuild-enbuild-genai-8488c86d6f-csfmn 1/1 Running 0 76m enbuild-enbuild-ui-56f5667d5b-4xckt 1/1 Running 0 76m enbuild-mongodb-0 1/1 Running 0 76m enbuild-rabbitmq-0 1/1 Running 0 76m enbuild-enbuild-backend-66676f8cd8-hxtbr 1/1 Running 0 76m enbuild-enbuild-user-b87d95b45-c79p6 1/1 Running 0 76m enbuild-enbuild-request-7c47c6d67b-j2fnd 1/1 Running 1 (73m ago) 76m enbuild-enbuild-ml-6f944ff759-ztdj6 1/1 Running 1 (73m ago) 76m enbuild-rabbitmq-1 1/1 Running 0 73m enbuild-rabbitmq-2 1/1 Running 0 72m enbuild-enbuild-mq-575c965764-zcnlg 1/1 Running 18 (6m24s ago) 76m ❗ Note: You might see restarts of the enbuild-enbuild-mq-* pod until the RabbitMQ service is up and running.\nValidate the ENBUILD services are setup correctly\nkubectl get services -n enbuild NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE enbuild-rabbitmq-headless ClusterIP None \u0026lt;none\u0026gt; 4369/TCP,5672/TCP,25672/TCP,15672/TCP 80s enbuild-mongo ClusterIP 10.43.230.6 \u0026lt;none\u0026gt; 27017/TCP 80s enbuild-enbuild-user ClusterIP 10.43.140.228 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-enbuild-ui ClusterIP 10.43.110.47 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-enbuild-backend ClusterIP 10.43.146.20 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-rabbitmq ClusterIP 10.43.54.197 \u0026lt;none\u0026gt; 5672/TCP,4369/TCP,25672/TCP,15672/TCP 80s Access ENBUILD Use the port forwarding command to access the ENBUILD UI using your web browser.\nkubectl --namespace enbuild port-forward svc/enbuild-enbuild-ui 3000:80 Forwarding from 127.0.0.1:3000 -\u0026gt; 8080 Forwarding from [::1]:3000 -\u0026gt; 8080 Navigate your web browser to http://127.0.0.1:3000. and set the admin password.\nAfter you set the initial admin password, you should see the ENBUILD home page with BigBang Catalog.\n⚡ Proceed to Configureing ENBUILD\nUninstall ENBUILD Use the following command to uninstall ENBUILD from your Kubernetes cluster.\nhelm uninstall enbuild -n enbuild release \u0026#34;enbuild\u0026#34; uninstalled ","date":"0001-01-01","id":13,"permalink":"/docs/how-to-guides/deploying-enbuild-for-local-testing/","summary":"Steps to deploy ENBUILD on local machine for quick testing","tags":[],"title":"Deploying ENBUILD for Local Testing"},{"content":"Follow these step-by-step instructions to configure ENBUILD.\nAfter you have successfully deployed the ENBUILD Helm Chart, you will need to configure the ENBUILD to deploy the Catalogs.\nSet the Admin Password You need to set the Admin Password before accessing the ENBUILD.\nConfigure the VCS Before deploying the catalog items, you need to configure the Version Control System (VCS). ENBUILD supports GitHub, GitLab VCS as of now.\nThese are the Version Control System where ENBUILD creates repositories when you deploy catalog item\nGITHUB Github Account \u0026ndash; The Github account where the deployment repositories will be created. Github Token \u0026ndash; The Token to be used to create deployment repositories Github Host \u0026ndash; The Github Host URL (e.g. https://github.com/) Github Branch \u0026ndash; The default branch for the deployment repositories (e.g. main) Github Host GQL URL \u0026ndash; The GraphQL API endpoint for the Github Host (e.g. https://api.github.com/graphql) Github Host URL \u0026ndash; The REST API endpoint for the Github Host (e.g. https://api.github.com) GITLAB Gitlab Host - The Gitlab Host (e.g. https://gitlab.com/) Gitlab Token - Gitlab Token to be used to create deployment repositories Gitlab Group - The Gitlab Group where the deployment repositories will be created Gitlab Namespace ID - The Gitlab Namespace ID of the group or user (e.g. 70306609) Configure SSO By default ENBUILD uses Local authentication, but you can choose to use either of\nKEYCLOAK OKTA Configure KEYCLOAK If you plan to use KEYCLOAK as SSO for authentication, you will need to configure the following:\nKeycloak Backend URL \u0026ndash; The Keycloak URL to authenticate users. Keycloak Client ID \u0026ndash; The Keycloak Client ID to authenticate users. Keycloak Realm \u0026mdash; The Keycloak REALM to authenticate users. ❗ Note: To provide these details, you need to existing keyclaok or you need to install and configure keycloak.\nConfigure OKTA If you plan to use OKTA as SSO for authentication, you will need to configure the following:\nOkta Client URL \u0026ndash; The Okta URL to authenticate users. Okta Client Secret \u0026ndash; The Okta Client Secret to authenticate users. Okta Client ID \u0026mdash; The Okta Client ID to authenticate users. Okta Base URL \u0026mdash; The Okta Base URL to authenticate users. Okta Client Token \u0026mdash; The Okta Client Token to authenticate users. ❗ Note: To provide these details, you need to configure okta and obtain the details.\n","date":"0001-01-01","id":14,"permalink":"/docs/how-to-guides/configuring-enbuild/","summary":"Configuring ENBUILD after installation","tags":[],"title":"Configuring ENBUILD"},{"content":"Prerequisites Before you begin, ensure that you have the following prerequisites in place:\nAccess to Platform1 registry Kubernetes cluster is up and running and you have access to it via kubectl command. Helm 3 installed on your system. Login to Platform1 registry Login to Platform1 registry by using the following command:\nhelm registry login registry1.dso.mil/bigbang WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /root/.kube/config WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /root/.kube/config Username: Juned_Memon Password: Login Succeeded Create Namespace and Image pull secret We need to create the istio-system and istio-operator namespaces.\nkubectl create ns istio-operator kubectl create ns istio-system Next, we need to create the imagePullSecret for pulling the images from Platform1 registry.\nFirst export the REGISTRY1_USER and REGISTRY1_PASSWORD with your P1 credentials.\nexport REGISTRY1_USER=\u0026lt;YOUR_REGISTRY1_USER\u0026gt; export REGISTRY1_PASSWORD=\u0026lt;YOUR_REGISTRY1_PASSWORD\u0026gt; Next, create the imagePullSecret for pulling the images from Platform1 registry.\nkubectl create secret -n istio-operator docker-registry private-registry --docker-server=registry1.dso.mil --docker-username=$REGISTRY1_USER --docker-password=$REGISTRY1_PASSWORD kubectl create secret -n istio-system docker-registry private-registry --docker-server=registry1.dso.mil --docker-username=$REGISTRY1_USER --docker-password=$REGISTRY1_PASSWORD Install istio-operator Helm charts Now install istio-operator Helm charts using the P1 Helm chart:\nhelm upgrade --install --namespace istio-operator istio-operator oci://registry1.dso.mil/bigbang/istio-operator --version 1.20.4-bb.0 --set imagePullSecrets[0]=\u0026#34;private-registry\u0026#34; --set createNamespace=false Verify the istio-operator pod is up and running:\n# kubectl get po -n istio-operator NAME READY STATUS RESTARTS AGE istio-operator-7b5fff8cfb-h6w4k 1/1 Running 0 18s Optional - Install CertManager Before installing the stio-controlplane we need a wildcard-cert secret containing the SSL certificate for the domain on which are planning to expose the virtual services.\nYou can use CertManager manage that TLS certificates and keys, or you can create them manually using openssl.\nHere, we will install CertManager and use self-signed-certificat.\nTo deploy a proper certificate using CertManager refer the official Documentation\nkubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml # kubectl get pods --namespace cert-manager NAME READY STATUS RESTARTS AGE cert-manager-67c98b89c8-g428w 1/1 Running 0 5m12s cert-manager-cainjector-5c5695d979-7qczq 1/1 Running 0 5m12s cert-manager-webhook-7f9f8648b9-2bt85 1/1 Running 0 5m12s Create a self signed cluster issuer\n--- apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: selfsigned-ca-issuer spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: selfsigned-ca namespace: cert-manager spec: isCA: true commonName: selfsigned-ca secretName: root-secret privateKey: algorithm: ECDSA size: 256 issuerRef: name: selfsigned-ca-issuer kind: ClusterIssuer group: cert-manager.io --- apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: selfsigned spec: ca: secretName: root-secret --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: self-sign-cert namespace: istio-system spec: secretName: wildcard-cert commonName: ijuned.com dnsNames: - ijuned.com - \u0026#34;*.ijuned.com\u0026#34; issuerRef: name: selfsigned kind: ClusterIssuer --- Apply the configurations\nkubectl apply -f self-sign-cert.yaml Install istio-controlplane Before installing the stio-controlplane we need a wildcard-cert secret containing the SSL certificate for the domain on which are planning to expose the virtual services.\nYou can create them manaully if you have the tls.key and tls.cert of your private certificate.\nOtherwise you can use Certmanager\nTo install the istio controlplane Helm chart.\nThe domain input that you provide, will be used to create a host entry in the istio Gateway named main\nhelm upgrade --install --namespace istio-system istio oci://registry1.dso.mil/bigbang/istio --version 1.20.4-bb.0 --set imagePullSecrets[0]=\u0026#34;private-registry\u0026#34; --set domain=\u0026#34;ijuned.com\u0026#34; ","date":"0001-01-01","id":15,"permalink":"/docs/how-to-guides/installing-istio/","summary":"Steps to Install Istio","tags":[],"title":"Installing  Istio"},{"content":"Introduction: In production Kubernetes environments, exposing the ENBUILD UI service requires careful consideration to ensure accessibility and security. While the Quick install of ENBUILD facilitates local testing through port forwarding, deploying in a production scenario demands a more robust approach. This document outlines various options available for exposing the ENBUILD UI service outside the Kubernetes cluster.\nOption 1: Expose UI using Kubernetes Service Type LoadBalancer Setting the service type to LoadBalancer enables external access to the ENBUILD UI service. Simply configure the service type as LB to allow external traffic. Refer to the example helm input file for guidance.\nOption 2: Use Service Type NodePort Configuring the service type as NodePort provides accessibility by exposing a specific port on all nodes in the cluster. Access the ENBUILD UI using the designated node port.\nRefer to the example helm input file for guidance.\nOption 3: Use Ingress Controller Installation and configuration of an Ingress controller within the Kubernetes cluster are prerequisites for this option. Expose the ENBUILD UI service through Ingress configuration for enhanced routing and management of external traffic. Refer to the example helm input file for guidance.\nOption 4: Expose Using Istio Virtual Service (Istio installation)[(docs/how-to-guides/installing-istio/)] and configuration are required for leveraging this option. Set the istio.enabled parameter to true and provide the necessary configurations, such as the Istio Virtual Service, to expose the ENBUILD UI service. Refer to the example helm input file for guidance.\nRefer the detailed guide of installing the ENBUILD on top of istio\n","date":"0001-01-01","id":16,"permalink":"/docs/how-to-guides/exposing-enbuild-ui/","summary":"Steps to Install Istio","tags":[],"title":"Exposing ENBUILD UI"},{"content":"Follow these step-by-step instructions to deploy ENBUILD locally for testing.\nPrerequisites Existing Kubernetes Cluster Ensure that you have access to a Kubernetes cluster and obtain the KubeConfig file.\nYou can use rancher-desktop or k3d to spin up a local Kubernetes cluster.\nENBUILD Container Images Access to the ENBUILD container images are required for this deployment. These images are published to the VivSoft managed container reigistry on registry.gitLab.com. Make sure that you have the necessary credentials to pull these images.\nHelm CLI The Helm streamlines and automates Kubernetes deployments by managing charts, enabling users to easily package, version, and deploy complex applications.\nIstio is deployed on your cluster Istio is a service mesh that enhances connectivity, security, traffic management, and observability for microservices.\nYou can follow the docs to install Istio on your cluster using the P1 Chart and Images\nDeployment Steps: Following are the steps you will need to take to deploy ENBUILD to your Kubernetes cluster.\nAdd ENBUILD Helm Chart Repository To add the ENBUILD Helm chart repository, run the following command:\nhelm repo add vivsoft https://vivsoftorg.github.io/enbuild \u0026#34;vivsoft\u0026#34; has been added to your repositories Configure ENBUILD Helm Values Before deploying ENBUILD to the Kubernetes cluster, you will need to create a custom values.yaml file so that we can specify configurations unique to this deployment.\nFor local deployment however we require minimum deployment values.\n❗ Note: For more information about the complete set of ENBUILD Helm values click here!\nimageCredentials: registry: registry.gitlab.com username: registry_user_name password: registry_password global: domain: ijuned.com # Set the proper doamin. istio: enabled: true gateway: istio-system/main # set to the proper istio gateway. This istio gateway must have above domain added as `hosts` ⚡ Note: The imageCredentials section is only required until the images are available publically.\nDeploy ENBUILD HELM Chart Make sure you update the values input to reference the values you created in Step 2. Execute the command below.\nhelm upgrade --install --namespace enbuild enbuild vivsoft/enbuild --create-namespace -f target/quick_install.yaml Release \u0026#34;enbuild\u0026#34; does not exist. Installing it now. NAME: enbuild LAST DEPLOYED: Fri Mar 22 17:37:23 2024 NAMESPACE: enbuild STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: 1. Get the application URL by running these commands: echo \u0026#34;Visit http://127.0.0.1:3000 to use your application after starting the port forward\u0026#34; kubectl --namespace enbuild port-forward svc/enbuild-enbuild-ui 3000:80 Validate ENBUILD Deployment Use the following commands to validate the ENBUILD pods are up and running.\nkubectl get pods -n enbuild NAME READY STATUS RESTARTS AGE enbuild-enbuild-genai-8488c86d6f-csfmn 1/1 Running 0 76m enbuild-enbuild-ui-56f5667d5b-4xckt 1/1 Running 0 76m enbuild-mongodb-0 1/1 Running 0 76m enbuild-rabbitmq-0 1/1 Running 0 76m enbuild-enbuild-backend-66676f8cd8-hxtbr 1/1 Running 0 76m enbuild-enbuild-user-b87d95b45-c79p6 1/1 Running 0 76m enbuild-enbuild-request-7c47c6d67b-j2fnd 1/1 Running 1 (73m ago) 76m enbuild-enbuild-ml-6f944ff759-ztdj6 1/1 Running 1 (73m ago) 76m enbuild-rabbitmq-1 1/1 Running 0 73m enbuild-rabbitmq-2 1/1 Running 0 72m enbuild-enbuild-mq-575c965764-zcnlg 1/1 Running 18 (6m24s ago) 76m ❗ Note: You might see restarts of the enbuild-enbuild-mq-* pod until the RabbitMQ service is up and running.\nValidate the ENBUILD services are setup correctly\nkubectl get services -n enbuild NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE enbuild-rabbitmq-headless ClusterIP None \u0026lt;none\u0026gt; 4369/TCP,5672/TCP,25672/TCP,15672/TCP 80s enbuild-mongo ClusterIP 10.43.230.6 \u0026lt;none\u0026gt; 27017/TCP 80s enbuild-enbuild-user ClusterIP 10.43.140.228 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-enbuild-ui ClusterIP 10.43.110.47 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-enbuild-backend ClusterIP 10.43.146.20 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-rabbitmq ClusterIP 10.43.54.197 \u0026lt;none\u0026gt; 5672/TCP,4369/TCP,25672/TCP,15672/TCP 80s Access ENBUILD Once the ENBUILD is installed, there will be two virtul services created. You can create a DNS record/host entry on your local machine pointing to these virtul services to the istio gateway loadbalancer/ip that you have used to install istio. global.istio.gateway\nkubectl get vs -A NAMESPACE NAME GATEWAYS HOSTS AGE enbuild enbuild-enbuild-ui [\u0026#34;istio-system/public-gateway\u0026#34;] [\u0026#34;enbuild.ijuned.com\u0026#34;] 4s enbuild enbuild-rabbitmq [\u0026#34;istio-system/public-gateway\u0026#34;] [\u0026#34;rabbitmq.ijuned.com\u0026#34;] 4s To find out the loadbalancer/ip of the istio gateway use the following command\nkubectl get svc -n istio-system istio-ingressgateway NAMESPACE NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE istio-system istio-ingressgateway LoadBalancer 10.43.60.241 \u0026lt;pending\u0026gt; 15021:32686/TCP,80:31687/TCP,443:30260/TCP 4m29s After the DNS entry / host entry , you can access the ENBUILD using the virtual service e.g.\nhttps://enbuild.ijuned.com\n❗ Note: If you have used self signed certificate, the browser will complain for it.\nUninstall ENBUILD Use the following command to uninstall ENBUILD from your Kubernetes cluster.\nhelm uninstall enbuild -n enbuild release \u0026#34;enbuild\u0026#34; uninstalled ","date":"0001-01-01","id":17,"permalink":"/docs/how-to-guides/deploying-enbuild-exposing-the-service-using-istio/","summary":"Follow these step-by-step instructions to deploy ENBUILD locally for testing.\nPrerequisites Existing Kubernetes Cluster Ensure that you have access to a Kubernetes cluster and obtain the KubeConfig file.","tags":[],"title":"Deploying ENBUILD exposing the service using Istio"},{"content":"Prerequisites Before you begin, ensure that you have the following prerequisites in place:\nAccess to Platform1 registry Kubernetes cluster is up and running and you have access to it via kubectl command. Helm 3 installed on your system. Login to Platform1 registry Login to Platform1 registry by using the following command:\nhelm registry login registry1.dso.mil/bigbang WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /root/.kube/config WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /root/.kube/config Username: Juned_Memon Password: Login Succeeded ","date":"0001-01-01","id":18,"permalink":"/docs/how-to-guides/install-and-configure-keycloak-for-enbuild-sso/","summary":"Install and Configure Keycloak for ENBUILD SSO","tags":[],"title":"Install and Configure Keycloak for ENBUILD SSO"},{"content":"Prerequisites Before you begin, ensure that you have the following prerequisites in place:\nENBUILD is installed and you have admin access to it. ","date":"0001-01-01","id":19,"permalink":"/docs/how-to-guides/adding-new-catalog-item-in-enbuild/","summary":"Adding new Catalog Item in ENBUILD","tags":[],"title":"Adding new Catalog Item in ENBUILD"},{"content":"This cheat sheet provides commonly used kubectl commands for managing Kubernetes clusters.\nBasic Commands\nList all pods\nkubectl get pods List all pods in a specific namespace\nkubectl get pods -n \u0026lt;namespace\u0026gt; List all nodes\nkubectl get nodes List all services\nkubectl get services ","date":"0001-01-01","id":20,"permalink":"/docs/troubleshooting/kubectl-cheat-sheet/","summary":"This cheat sheet provides commonly used kubectl commands for managing Kubernetes clusters.\nBasic Commands\nList all pods\nkubectl get pods List all pods in a specific namespace","tags":[],"title":"Kubectl Cheat Sheet"},{"content":" About Q: Who is behind this project?\nA: VivSoft! 🐘 VivSoft is focused on solving complex problems in the public sector using innovative technologies. VivSoft is working with business leaders in federal, state and local government to help mission owners accelerate innovation using DevSecOps, Cloud, AI/ML and Blockchain Technologies.\nQ: What problem does ENBUILD solve?\nA: ENBUILD\u0026rsquo;s goal is to empower organizations to leverage Kubernetes and cloud-native technologies effectively while minimizing the complexity and overhead associated with deployment and management tasks. By offering pre-configured catalog items and promoting best practices, ENBUILD enables organizations to streamline their development workflows, reduce time to market, and achieve their product development goals more efficiently.\nCosts and Licensing Fees Q: Is ENBUILD free to use?\nA: Yes, ENBUILD is free to use.\nQ: What license does ENBUILD use?\nA: ENBUILD utilizes the Apache License, which is an open-source software license recognized for its flexibility and permissive nature. This license allows users to freely use, modify, and distribute the software, whether for personal, commercial, or open-source projects. For more detailed information about the Apache License and its implications, please refer to the official Apache Software Foundation website or consult the license file included with the ENBUILD software distribution.\nSecurity Q: What dependencies does ENBUILD have?\nA: ENBUILD, being a Kubernetes native application, relies on certain dependencies to function optimally. These dependencies include:\nKubernetes Cluster: ENBUILD requires a Kubernetes cluster to operate. This ensures that ENBUILD can leverage the scalability, resilience, and orchestration capabilities provided by Kubernetes, thereby enabling efficient deployment and management of containerized applications. Version Control System (VCS) for ENBUILD Catalog Item Deployments: ENBUILD utilizes a Version Control System for managing and deploying ENBUILD Catalog Items. Currently, ENBUILD supports integration with two popular VCS platforms:\nGitLab: ENBUILD seamlessly integrates with GitLab, allowing users to leverage the robust features of GitLab for managing and versioning their ENBUILD Catalog Items. This includes support for both the Software as a Service (SaaS) offering of GitLab and self-hosted deployments of GitLab instances.\nGitHub: ENBUILD also supports integration with GitHub, enabling users to utilize GitHub\u0026rsquo;s collaborative features and version control capabilities for ENBUILD Catalog Item deployments. Similar to GitLab, ENBUILD supports both the SaaS offering of GitHub and self-hosted deployments of GitHub Enterprise instances.\nBy supporting these Version Control Systems, ENBUILD provides users with flexibility and choice, allowing them to seamlessly integrate ENBUILD into their existing development workflows while leveraging the capabilities of their preferred VCS platform.\nFor further details on setting up ENBUILD dependencies and integration with specific Version Control Systems, please refer to the ENBUILD documentation or reach out to our support team for assistance.\nDeployment Q: What types of Kubernetes distributions is ENBUILD compatible with?\nA: ENBUILD has been deployed and tested on the following distributions of Kubernetes:\nAmazon EKS (Elastic Kubernetes Service): ENBUILD is fully compatible with Amazon EKS, allowing users to deploy and manage ENBUILD on Amazon Web Services\u0026rsquo; managed Kubernetes service. Azure AKS (Azure Kubernetes Service): ENBUILD seamlessly integrates with Azure AKS, enabling users to deploy and run ENBUILD on Microsoft Azure\u0026rsquo;s managed Kubernetes service. Rancher K3D: ENBUILD supports deployment on Rancher K3D, a lightweight Kubernetes distribution designed for local development and testing purposes. Rancher RKE2: ENBUILD is compatible with Rancher RKE2, an enterprise-grade Kubernetes distribution optimized for production workloads. Configuration Q: What is an ENBUILD Catalog Item (CI)?\nA: An ENBUILD Catalog Item, often abbreviated as CI, serves as a standardized template project designed to streamline the deployment and management of various infrastructure components and applications within the ENBUILD ecosystem. These Catalog Items are meticulously crafted by developers to encapsulate pre-configured settings, best practices, and reusable components, providing users with a simplified and consistent approach to deploying complex infrastructure and applications.\nENBUILD Catalog Items are tailored to support a diverse range of use cases and technologies, including:\nTerraform Infrastructure as Code (IaC): Catalog Items for Terraform enable users to define and manage cloud infrastructure resources using Infrastructure as Code principles. These Catalog Items offer pre-defined templates and configurations for provisioning resources on popular cloud platforms such as AWS, Azure, and Google Cloud Platform, facilitating rapid deployment and automation of infrastructure provisioning tasks.\nKubernetes Distributions (e.g., Amazon EKS, Azure AKS): Catalog Items for Kubernetes distributions provide users with pre-configured templates for deploying and managing Kubernetes clusters on various cloud providers, such as Amazon EKS (Elastic Kubernetes Service) and Azure AKS (Azure Kubernetes Service). These Catalog Items simplify the setup and configuration of Kubernetes clusters, enabling users to leverage the scalability and agility of Kubernetes for containerized application deployment and orchestration.\nHelm Deployments (e.g., Big Bang): Catalog Items for Helm deployments offer pre-packaged configurations and charts for deploying applications and services using Helm, a popular package manager for Kubernetes. These Catalog Items streamline the deployment of complex applications by providing ready-to-use Helm charts and configurations, reducing the time and effort required for setting up and configuring application environments.\nBy leveraging ENBUILD Catalog Items, developers gain access to a curated library of templates and configurations that serve as starting points for their projects. These Catalog Items not only accelerate the development and deployment process but also promote consistency, reliability, and best practices across projects within the ENBUILD ecosystem.\nQ: What is an ENBUILD Version Control System (VCS)?\nA: A Version Control System (VCS) is a fundamental tool used in software development to manage and track changes to source code, configuration files, and other project assets over time. It allows multiple developers to collaborate on a project concurrently while maintaining a history of all modifications made to the project files.\nIn the context of ENBUILD, a Version Control System (VCS) plays a crucial role in managing and deploying ENBUILD Catalog Items, which are template projects designed to facilitate the deployment of infrastructure components and applications within the ENBUILD ecosystem. ENBUILD supports integration with popular VCS platforms such as GitLab and GitHub, providing users with the flexibility to version control their Catalog Items and streamline the deployment process.\nKey features and benefits of using a Version Control System (VCS) include:\nHistory Tracking: VCS systems maintain a detailed history of changes made to project files, including who made the changes and when they were made. This allows developers to review past revisions, track the evolution of the project, and revert to previous versions if necessary.\nCollaboration: VCS systems enable seamless collaboration among team members by providing mechanisms for sharing and synchronizing changes to project files. Multiple developers can work on the same codebase simultaneously without risking conflicts or data loss.\nBranching and Merging: VCS systems support branching and merging workflows, allowing developers to create separate branches to work on specific features or fixes independently. Branches can later be merged back into the main codebase, ensuring a streamlined and organized development process.\nAuditing and Compliance: VCS systems offer auditing capabilities that help maintain compliance with regulatory requirements and internal policies. Organizations can track and monitor all changes made to project files, ensuring accountability and transparency in the development process.\nBy leveraging a Version Control System (VCS) such as GitLab or GitHub, ENBUILD users can effectively manage their Catalog Items, collaborate with team members, track changes, and maintain a consistent and reliable deployment workflow.\nChange Control Q: What is the Release schedule?\nA: To Be Determined. 📆\n","date":"0001-01-01","id":21,"permalink":"/docs/faq/frequently-asked-questions/","summary":"About Q: Who is behind this project?\nA: VivSoft! 🐘 VivSoft is focused on solving complex problems in the public sector using innovative technologies.","tags":[],"title":"Frequently Asked Questions"},{"content":"To be added ","date":"0001-01-01","id":22,"permalink":"/docs/faq/glossary/","summary":"To be added ","tags":[],"title":"Glossary"},{"content":" ArgoCD, a declarative, GitOps continuous delivery tool for Kubernetes, revolutionizes the application deployment process. At its essence, ArgoCD enables organizations to manage and automate the deployment of applications through Git repositories, promoting a declarative approach to configuration and versioning. It continuously monitors the desired state of applications defined in Git and automatically reconciles any divergences with the current state in the Kubernetes cluster. This ensures that applications are consistently deployed and maintained across different environments. ArgoCD\u0026rsquo;s intuitive user interface provides visibility into the deployment status, allowing for easy tracking and rollbacks. With support for multiple clusters and repositories, ArgoCD empowers teams to achieve efficient, scalable, and auditable continuous delivery workflows in Kubernetes environments.\nSample ArgoCD Commands Below is a list of common ArgoCD CLI commands for managing Kubernetes applications:\nLogging in to Argo CD Server To log in to the Argo CD server, use the following command:\nargocd login \u0026lt;argocd-server-url\u0026gt; --username \u0026lt;username\u0026gt; --password \u0026lt;password\u0026gt; Setting the Current Context Before executing any Argo CD CLI commands, you need to set the current context to the Argo CD server:\nargocd context \u0026lt;argocd-server-url\u0026gt; Listing Applications List all applications managed by Argo CD:\nargocd app list Getting Information about an Application Retrieve detailed information about a specific application:\nargocd app get \u0026lt;application-name\u0026gt; Syncing an Application Manually sync an application with its target state:\nargocd app sync \u0026lt;application-name\u0026gt; Setting Sync Options You can set various sync options for an application. For example:\nargocd app set \u0026lt;application-name\u0026gt; --sync-policy \u0026lt;policy\u0026gt; Deleting an Application Delete an application from Argo CD:\nargocd app delete \u0026lt;application-name\u0026gt; Configuring Auto-Sync Enable or disable auto-sync for an application:\nargocd app auto-sync \u0026lt;application-name\u0026gt; --\u0026lt;enable/disable\u0026gt; Viewing Application Resources List Kubernetes resources managed by an application:\nargocd app resources \u0026lt;application-name\u0026gt; Accessing Argo CD Web UI You can also access the Argo CD Web UI by running:\nargocd open Logging out of Argo CD Server To log out of the Argo CD server, run:\nargocd logout Further Reading Read argocd Official Documentation ","date":"0001-01-01","id":23,"permalink":"/docs/references/argocd/","summary":"ArgoCD, a declarative, GitOps continuous delivery tool for Kubernetes, revolutionizes the application deployment process. At its essence, ArgoCD enables organizations to manage and automate the deployment of applications through Git repositories, promoting a declarative approach to configuration and versioning.","tags":[],"title":"ArgoCD"},{"content":" Big Bang is a declarative, continuous delivery tool for deploying DoD hardened and approved packages into a Kubernetes cluster.\nUsage \u0026amp; Scope Big Bang\u0026rsquo;s scope is to provide publicly available installation manifests for packages required to adhere to the DoD DevSecOps Reference Architecture and additional useful utilities. Big Bang packages are broken into three categories:\nCore: Core packages are a group of capabilities required by the DoD DevSecOps Reference Architecture, that are supported directly by the Big Bang development team. The specific capabilities that are considered core currently are Service Mesh, Policy Enforcement, Logging, Monitoring, and Runtime Security.\nAddons: Addon packages are any packages/capabilities that the Big Bang development team directly supports that do not fall under the above core definition. These serve to extend the functionality/features of Big Bang.\nCommunity: Community packages are any packages that are maintained by the broader Big Bang community (users, vendors, etc). These packages could be alternatives to core or addon packages, or even entirely new packages to help extend usage/functionality of Big Bang.\nIn order for an installation of Big Bang to be a valid installation/configuration you must install/deploy a core package of each category (for additional details on categories and options see here).\nBig Bang also builds tooling around the testing and validation of Big Bang packages. These tools are provided as-is, without support.\nBig Bang is intended to be used for deploying and maintaining a DoD hardened and approved set of packages into a Kubernetes cluster. Deployment and configuration of ingress/egress, load balancing, policy auditing, logging, monitoring, etc. are handled via Big Bang. Additional packages (e.g. ArgoCD, GitLab) can also be enabled and customized to extend Big Bang\u0026rsquo;s baseline. Once deployed, the Kubernetes cluster can be used to add mission specific applications.\nFurther Reading Read big bang Official Documentation Checkout big bang on GitHub ","date":"0001-01-01","id":24,"permalink":"/docs/references/platform-one-big-bang/","summary":"Big Bang is a declarative, continuous delivery tool for deploying DoD hardened and approved packages into a Kubernetes cluster.","tags":[],"title":"Platform One Big Bang"},{"content":" GitLab stands as a comprehensive DevOps platform, providing end-to-end solutions for source code management, continuous integration, delivery, security, and more. As an integrated tool, GitLab facilitates collaboration among development, operations, and security teams, streamlining the entire software development lifecycle. With its version control capabilities based on Git, GitLab allows teams to efficiently manage and track changes in their codebase. Beyond version control, GitLab\u0026rsquo;s robust CI/CD pipelines automate the building, testing, and deployment of applications, ensuring rapid and reliable delivery. The platform also emphasizes security with built-in features for code scanning, vulnerability management, and compliance tracking. GitLab\u0026rsquo;s all-in-one approach fosters collaboration, transparency, and efficiency, making it a preferred choice for organizations aiming to achieve seamless and integrated DevOps workflows.\nFurther Reading Read gitlab Official Documentation ","date":"0001-01-01","id":25,"permalink":"/docs/references/gitlab/","summary":"GitLab stands as a comprehensive DevOps platform, providing end-to-end solutions for source code management, continuous integration, delivery, security, and more.","tags":[],"title":"GitLab"},{"content":" The Helm CLI serves as a powerful package manager for Kubernetes applications, streamlining and simplifying the deployment and management of complex containerized applications. At its core, Helm utilizes charts—pre-configured packages of Kubernetes resources—to encapsulate and version entire applications. With the Helm CLI, users can effortlessly install, upgrade, and roll back applications, ensuring consistent and reproducible deployments across different environments. Its templating system allows for easy customization of configurations, while the Helm repository facilitates the sharing and distribution of charts. Whether orchestrating microservices or deploying scalable applications, Helm proves to be an indispensable tool for developers and operators seeking efficiency and consistency in Kubernetes environments. Sample Helm Commands Below is a list of common Helm CLI commands for managing Kubernetes applications:\nInitializing Helm Initialize Helm in your Kubernetes cluster:\nhelm init Adding a Helm Repository Add a repository containing Helm Charts:\nhelm repo add stable https://charts.helm.sh/stable Searching for Helm Charts Searching for Helm charts in the added repositories:\nhelm search repo \u0026lt;keyword\u0026gt; Installing a Helm Chart Install a Helm chart into your Kubernetes cluster:\nhelm install \u0026lt;release-name\u0026gt; \u0026lt;chart-name\u0026gt; Listing Installed Helm Releases List all installed Helm releases:\nhelm list Getting Information about a Release Get information about a specific Helm release:\nhelm status \u0026lt;release-name\u0026gt; Upgrading a Helm Release Upgrade a Helm release to a new version:\nhelm upgrade \u0026lt;release-name\u0026gt; \u0026lt;chart-name\u0026gt; Deleting a Helm Release Delete a Helm release from your Kubernetes cluster:\nhelm delete \u0026lt;release-name\u0026gt; Viewing Helm Release History View the history of changes for a Helm release:\nhelm history \u0026lt;release-name\u0026gt; Uninstalling Helm To uninstall Helm from your Kubernetes cluster, run:\nhelm reset Further Reading Read helm Official Documentation ","date":"0001-01-01","id":26,"permalink":"/docs/references/helm/","summary":"The Helm CLI serves as a powerful package manager for Kubernetes applications, streamlining and simplifying the deployment and management of complex containerized applications.","tags":[],"title":"Helm"},{"content":" Istio, a robust and open-source service mesh platform, redefines how microservices communicate within a Kubernetes environment. Acting as a dedicated layer for managing and securing microservice interactions, Istio provides a comprehensive set of tools for traffic management, load balancing, and observability. By intelligently routing and controlling the flow of traffic between services, Istio enhances resilience, fault tolerance, and overall service reliability. Its built-in security features, such as mutual TLS authentication and access control, fortify communication channels between microservices. Additionally, Istio\u0026rsquo;s observability capabilities, including distributed tracing and metrics collection, offer insights into application performance. With Istio, organizations can effortlessly implement a resilient and secure microservices architecture, ultimately improving the manageability and reliability of their containerized applications. Sample Istio Commands Below is a list of common Istio CLI commands for managing Istio service mesh:\nInstalling Istio Install Istio into your Kubernetes cluster:\nistioctl install Verifying Istio Installation Verify that Istio components are installed correctly:\nistioctl verify-install Listing Istio Virtual Services List all Istio Virtual Services in the cluster:\nistioctl get virtualservices Creating a Virtual Service Create a new Istio Virtual Service:\nistioctl create -f virtual-service.yaml Updating a Virtual Service Update an existing Istio Virtual Service:\nistioctl replace -f virtual-service.yaml Deleting a Virtual Service Delete an Istio Virtual Service:\nistioctl delete virtualservice \u0026lt;virtual-service-name\u0026gt; Listing Istio Gateways List all Istio Gateways in the cluster:\nistioctl get gateways Viewing Istio Service Mesh Dashboard Access the Istio Service Mesh dashboard:\nistioctl dashboard kiali Generating Istio Service Graph Generate a service graph for Istio services:\nistioctl analyze Viewing Istio Proxy Logs View logs from Istio proxies:\nistioctl proxy-config log \u0026lt;pod-name\u0026gt; Upgrading Istio Upgrade Istio to a newer version:\nistioctl upgrade -f istio-upgrade.yaml Uninstalling Istio Uninstall Istio from your Kubernetes cluster:\nistioctl x uninstall --purge Further Reading Read istio Official Documentation ","date":"0001-01-01","id":27,"permalink":"/docs/references/istio/","summary":"Istio, a robust and open-source service mesh platform, redefines how microservices communicate within a Kubernetes environment. Acting as a dedicated layer for managing and securing microservice interactions, Istio provides a comprehensive set of tools for traffic management, load balancing, and observability.","tags":[],"title":"Istio"},{"content":" K3D, a lightweight and versatile tool, simplifies the management and deployment of Kubernetes clusters by bringing the power of Kubernetes into a single-node environment. Designed for simplicity and speed, K3D allows developers and operators to spin up Kubernetes clusters with ease, making it an ideal choice for local development, testing, and CI/CD pipelines. Leveraging containerd and other containerization technologies, K3D offers a minimalistic yet efficient Kubernetes experience. Users can create, scale, and delete clusters effortlessly, making it a valuable tool for scenarios where resource constraints or rapid cluster provisioning are crucial. With K3D, developers can focus on building and testing applications in a Kubernetes-like environment without the complexity of managing large-scale clusters, thereby accelerating the development lifecycle.\nSample K3D Commands Below is a list of basic K3D CLI commands for managing Kubernetes clusters:\nCreating a Kubernetes Cluster Create a new Kubernetes cluster using k3d:\nk3d cluster create \u0026lt;cluster-name\u0026gt; Listing Kubernetes Clusters List all existing Kubernetes clusters managed by k3d:\nk3d cluster list Getting Information about a Cluster Retrieve detailed information about a specific Kubernetes cluster:\nk3d cluster get \u0026lt;cluster-name\u0026gt; Accessing Kubernetes Cluster Set the kubeconfig context to the newly created Kubernetes cluster:\nexport KUBECONFIG=\u0026#34;$(k3d kubeconfig write \u0026lt;cluster-name\u0026gt;)\u0026#34; Deleting a Kubernetes Cluster Delete a Kubernetes cluster managed by k3d:\nk3d cluster delete \u0026lt;cluster-name\u0026gt; Starting a Kubernetes Cluster Start a previously stopped Kubernetes cluster:\nk3d cluster start \u0026lt;cluster-name\u0026gt; Stopping a Kubernetes Cluster Stop a running Kubernetes cluster:\nk3d cluster stop \u0026lt;cluster-name\u0026gt; Scaling Nodes Scale the number of worker nodes in the cluster:\nk3d node create \u0026lt;node-name\u0026gt; --replicas \u0026lt;num-replicas\u0026gt; Exporting kubeconfig Export the kubeconfig file for a cluster:\nk3d kubeconfig write \u0026lt;cluster-name\u0026gt; Further Reading Read k3d Official Documentation ","date":"0001-01-01","id":28,"permalink":"/docs/references/k3d/","summary":"K3D, a lightweight and versatile tool, simplifies the management and deployment of Kubernetes clusters by bringing the power of Kubernetes into a single-node environment.","tags":[],"title":"K3D"},{"content":"","date":"2023-09-07","id":29,"permalink":"/","summary":"","tags":[],"title":"ENBUILD"},{"content":"","date":"2023-09-07","id":30,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"0001-01-01","id":31,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":32,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":33,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]