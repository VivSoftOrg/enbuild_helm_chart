[{"content":"","date":"2023-09-07","id":0,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"Overview ENBUILD is a cutting-edge software development and engineering tool designed to simplify the complexities of modern-day DevSecOps, containerization and cloud tooling. At its core, ENBUILD offers a self-service catalog featuring pre-packaged templates known as ENBUILD Catalog Items. These templates encompass Terraform Infrastructure deployments on major cloud platforms (AWS, Azure, GCP) and Helm Deployments onto Kubernetes, providing developers with a robust foundation for both infrastructure and application deployment. With automated GitLab and GitHub workflows and pipelines, ENBUILD streamlines the deployment process, allowing developers to focus on value-added work.\nThis tool is specifically tailored for the United States Department of Defense and Government Organizations embarking on DevSecOps Transformation, Cloud Migration, or Platform Development journeys. ENBUILD serves as a strategic accelerator for the adoption of the United States Air Force\u0026rsquo;s Platform One Big Bang Tech Stack, enabling rapid and secure software development and deployment. With seamless integration into popular Continuous Integration / Continuous Deployment engines like GitLab and GitHub, ENBUILD ensures a unified development lifecycle. Moreover, its integration with identity and access management solutions, including Keycloak and Okta, ensures compliance with government regulations through robust Role-Based Access Control (RBAC).\nAs a Kubernetes-native deployment, ENBUILD provides versatility across various Kubernetes environments, supporting AWS EKS, Azure AKS, Rancher, OpenShift, and more. By abstracting toil work and complexities, ENBUILD aims to meet 60-70% of developers\u0026rsquo; needs out of the box, offering a solid starting point for customization and specialization. In summary, ENBUILD stands as a comprehensive solution, empowering organizations to enhance their development processes, accelerate cloud adoption, and navigate the challenges of modern software engineering and infrastructure deployment with ease.\n","date":"2023-09-07","id":1,"permalink":"/docs/getting-started/introduction/","summary":"Overview ENBUILD is a cutting-edge software development and engineering tool designed to simplify the complexities of modern-day DevSecOps, containerization and cloud tooling.","tags":[],"title":"Introduction"},{"content":"","date":"2023-09-07","id":2,"permalink":"/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"\nENBUILD addresses the challenges associated with Day 1 installation and configuration of a Big Bang Kubernetes cluster, offering a streamlined approach for Day 2 operations, including platform upgrades and automation tool patches.\nEase of Use: ENBUILD simplifies Big Bang deployments through a user-friendly UI that facilitates the selection and configuration of DevSecOps pipeline tools. It alleviates common pain points, such as secrets creation and Helm configurations, by utilizing pre-created templates.\nFaster Deployment and Continuous ATO: ENBUILD significantly reduces deployment times, enabling organizations to deploy Big Bang in days rather than weeks or months. It expedites approval processes by leveraging Iron Bank accredited containers.\nOn-Premise \u0026amp; Multi-Cloud Support: ENBUILD provides flexibility by supporting on-premise and cloud deployments across various environments, from edge to commercial Clouds, government Clouds, and air-gapped environments. It allows the deployment of Big Bang stacks on AWS and Azure GovCloud, showcasing cloud-agnostic components.\nOut of the Box Security: Built on pre-hardened DISA compliant containers from Iron Bank, ENBUILD ensures robust security. It incorporates built-in GitOps and Secrets Management for enterprise-grade deployments.\nPre-Built Catalog of Solutions: ENBUILD offers a pre-built catalog featuring solutions for AI/ML deployments using KubeFlow, secure Cloud Computing Architecture based Landing Zones, and data ingestion stacks using Nifi/Kafka/Spark.\nNo Vendor Lock-in: ENBUILD serves as a service delivery accelerator without licensing fees, promoting cost efficiency. It relies on open-source components, fostering a vendor-agnostic approach for greater flexibility and adaptability.\n","date":"2023-09-07","id":3,"permalink":"/docs/getting-started/what-is-enbuild/","summary":"ENBUILD addresses the challenges associated with Day 1 installation and configuration of a Big Bang Kubernetes cluster, offering a streamlined approach for Day 2 operations, including platform upgrades and automation tool patches.","tags":[],"title":"What is ENBUILD?"},{"content":"","date":"2023-09-07","id":4,"permalink":"/docs/how-to-guides/","summary":"","tags":[],"title":"How-to Guides"},{"content":"","date":"2023-09-07","id":5,"permalink":"/docs/troubleshooting/","summary":"","tags":[],"title":"Troubleshooting"},{"content":"ENBUILD operates as a bridge between developers and the Continuous Integration/Continuous Deployment (CI/CD) systems, specifically with popular platforms like GitHub and GitLab. This tool simplifies the entire software development process, making it accessible and efficient for users with various technical backgrounds.\nGitHub Integration When working with GitHub, ENBUILD seamlessly communicates with the CI/CD provider through REST and GraphQL APIs. It starts by creating a Repository Project, essentially a structured workspace, using a template repository project. The user interacts with ENBUILD through an intuitive user interface (UI), providing inputs that guide the customization of files. These files are then updated based on the user\u0026rsquo;s preferences. Once the configuration is complete, ENBUILD executes the predefined workflow or pipeline, automating the deployment process without the need for intricate manual steps.\nGitLab Integration Similarly, when integrating with GitLab, ENBUILD initiates the process by creating a Repository Project within the GitLab environment. Just like with GitHub, the user\u0026rsquo;s inputs through the ENBUILD UI guide the customization of files within the project. ENBUILD updates these files accordingly, ensuring that the project aligns with the user\u0026rsquo;s specifications. Subsequently, the tool triggers the execution of the workflow or pipeline, seamlessly automating the development and deployment steps.\nIn essence, ENBUILD acts as a facilitator, taking the complexities out of setting up projects and workflows. It empowers users to customize their development environments through a straightforward UI, enabling a smooth and efficient interaction with CI/CD systems like GitHub and GitLab. The result is an accelerated and simplified software development process, allowing developers to focus on building innovative solutions without getting bogged down by technical intricacies.\n","date":"2023-09-07","id":6,"permalink":"/docs/getting-started/how-enbuild-works/","summary":"ENBUILD operates as a bridge between developers and the Continuous Integration/Continuous Deployment (CI/CD) systems, specifically with popular platforms like GitHub and GitLab.","tags":[],"title":"How ENBUILD works"},{"content":"Test ","date":"2023-09-07","id":7,"permalink":"/docs/faq/","summary":"Test ","tags":[],"title":"FAQ"},{"content":"Architecture Digram Frontend Service The ENBUILD frontend service provides the ENBUILD User Interface (UI) to the end user.\nBackend Service The ENBUILD backend service is responsible for integration with the CI/CD Provider.\nUser Service The ENBUILD user service manages the end-user\u0026rsquo;s state, such as authentication, access, API access and role-based access control.\nML Service The ENBUILD ML (Machine Learning) service enables data scientists to quickly create feature sets and deploy models. An instance of Jupyter Notebook can also be created and accessed from this service.\nRequest Service ???\nRabbitMQ Consumer Service The ENBUILD RabbitMQ consumer service processes jobs in the work queue as well as integrates with the CI/CD Provider APIs.\nNoSQL Database ENBUILD utilizes a NoSQL database to manage the application’s state across all microservices. ENBUILD provides a MongoDB instance out-of-the-box, but also can integrate with Cloud Service Provider NoSQL Databases such as Azure’s CosmosDB and AWS’ DocumentDB.\nIdentity and Access Management ENBUILD supports integration with Okta and Keycloak. Keycloak can act as an Identity Broker for other IdAM products such as Active Directory.\n","date":"2023-09-07","id":8,"permalink":"/docs/getting-started/architecture/","summary":"Architecture Digram Frontend Service The ENBUILD frontend service provides the ENBUILD User Interface (UI) to the end user.\nBackend Service The ENBUILD backend service is responsible for integration with the CI/CD Provider.","tags":[],"title":"Architecture"},{"content":"","date":"2023-09-07","id":9,"permalink":"/docs/references/","summary":"","tags":[],"title":"References"},{"content":"ENBUILD Helm Chart Values The following key value pairs are used to configure ENBUILD.\nParameters Global parameters Name Description Value global.AppVersion [default: \u0026ldquo;\u0026rdquo;] Provide custom appVersion, to override the default one. All the ENBUILD images will be of the same version. To use indidual tag for each service set the tag on per service basis. \u0026quot;\u0026quot; global.domain What domain to use to expose the ENBUILD using istio or Ingress ijuned.com global.disable_tls_gitlab Set to true if you are using self-signed certificates false global.ingress.enabled Should we create the Ingress Resources ? false global.ingress.tls Is Ingress TLS enabled ? false global.ingress.tls_secret If Ingress is TLS enabled, Provide the Secret for the TLS Certificate. \u0026quot;\u0026quot; global.ingress.classname Ingress classname if enabled. \u0026quot;\u0026quot; global.ingress.annotations Ingress annotations if enabled. [] global.istio.enabled Should we create the Istio Resources ? false global.istio.gateway Istio gateway to use for creating Virtual Service. istio-system/public-gateway Container Registry Parameters Name Description Value imageCredentials Should we use a private container registry? if yes provide the following parameters {} imageCredentials.registry Container registry Path \u0026quot;\u0026quot; imageCredentials.username Container registry Username \u0026quot;\u0026quot; imageCredentials.password Container registry password \u0026quot;\u0026quot; Jupyterhub Parameters Name Description Value jupyterhub.cull.enabled Deploy Jupyterhub false ENBUILD RabbitMQ parameters Name Description Value rabbitmq.enabled Set to false to use existing RabbitMQ true rabbitmq.replicaCount RabbitMQ replicaCount 1 rabbitmq.auth.username RabbitMQ username admin rabbitmq.auth.password RabbitMQ password SuperSecret rabbitmq.auth.erlangCookie RabbitMQ erlangCookie lamba rabbitmq.host If rabbitmq.enabled is false , provide the right rabbitmq endpoint \u0026quot;\u0026quot; rabbitmq.queue_prefix Queue Prefix for all RabbitMQ Queues enbuild ENBUILD Backend/DB parameters Name Description Value mongodb.enabled Set to true to Deploy the MongoDB. false mongodb.mongo_root_username DB username. If mongodb.enabled this is used to to set the username. Else this is username for existing Cosmos or DocumentDB \u0026quot;\u0026quot; mongodb.mongo_root_password DB Password. If mongodb.enabled this is used to to set the password. Else this is password for existing Cosmos or DocumentDB \u0026quot;\u0026quot; mongodb.mongo_server If mongodb.enabled is false , provide the right cosmosDB/DocumentDB endpoint \u0026quot;\u0026quot; mongodb.image.repository Container repository for mongodb Container registry.gitlab.com/enbuild-staging/container_registry/opensource-mongodb/mongodb mongodb.image.tag Container tag for mongodb Container 4.4.5 mongodb.image.pullPolicy Container ImagePullPolicy for mongodb Container Always ENBUILD UI Services parameters Name Description Value enbuildUi.image.repository Container repository for enbuildUi registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-frontend enbuildUi.image.pullPolicy Container image pullPolicy Always enbuildUi.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildUi.replicas Container enbuildUI Replicas 1 enbuildUi.service_type enbuildUI service_type ClusterIP enbuildUi.node_port enbuildUI node_port 30080 enbuildUi.hostname enbuild service hostname. enbuildUi.hostname.global.domain becomes your FQDN enbuild enbuildUi.kiali_url kiali_url https://kiali.ijuned.com/kiali/ enbuildUi.grafana_url grafana_url https://grafana.ijuned.com/ enbuildUi.loki_url loki_url https://grafana.ijuned.com/d/liz0yRCZz/logs-app?orgId=1 enbuildUi.kubecost_url kubecost_url https://kubecost.ijuned.com/overview.html ENBUILD Backend Services parameters Name Description Value enbuildBk.image.repository Container repository for enbuildBk registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-backend enbuildBk.image.pullPolicy Container image pullPolicy Always enbuildBk.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildBk.replicas Container enbuildBk Replicas 1 enbuildBk.service_type enbuildBk service_type ClusterIP enbuildBk.encryption_key encryption_key to be used by Backend encryption_key ENBUILD USER Services parameters Name Description Value enbuildUser.image.repository Container repository for enbuildUser registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-user enbuildUser.image.pullPolicy Container image pullPolicy Always enbuildUser.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildUser.replicas Container enbuildUser Replicas 1 enbuildUser.service_type enbuildUser service_type ClusterIP ENBUILD Sync Services parameters Name Description Value enbuildSync.image.repository Container repository for enbuildSync registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-cronjob enbuildSync.image.pullPolicy Container image pullPolicy Always enbuildSync.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildSync.replicas Container enbuildSync Replicas 1 ENBUILD ML Services parameters Name Description Value enbuildMl.enabled Should we create the ENBUILD ML microservice ? false enbuildMl.image.repository Container repository for enbuildMl registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-ml enbuildMl.image.pullPolicy Container image pullPolicy Always enbuildMl.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildMl.replicas Container enbuildMl Replicas 1 enbuildMl.service_type enbuildMl service_type ClusterIP ENBUILD GenAI Services parameters Name Description Value enbuildGenAI.enabled Should we create the ENBUILD GenAI microservice ? false enbuildGenAI.image.repository Container repository for enbuildGenAI registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-genai enbuildGenAI.image.pullPolicy Container image pullPolicy Always enbuildGenAI.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildGenAI.replicas Container enbuildGenAI Replicas 1 enbuildGenAI.service_type enbuildGenAI service_type ClusterIP enbuildGenAI.api_key api_key for OpenAI service. dummy ENBUILD Request Services parameters Name Description Value enbuildRequest.enabled Should we create the ENBUILD Request microservice ? false enbuildRequest.image.repository Container repository for enbuildRequest registry.gitlab.com/enbuild-staging/vivsoft-platform-ui/enbuild-request enbuildRequest.image.pullPolicy Container image pullPolicy Always enbuildRequest.image.tag Container image tag. Skip to use the HelmChart appVersion as Image Tag undefined enbuildRequest.replicas Container enbuildRequest Replicas 1 enbuildRequest.service_type enbuildRequest service_type ClusterIP ","date":"2023-09-07","id":10,"permalink":"/docs/getting-started/helm-values/","summary":"ENBUILD Helm Chart Values The following key value pairs are used to configure ENBUILD.\nParameters Global parameters Name Description Value global.","tags":[],"title":"Helm Values"},{"content":"The ENBUILD Manifest serves as the backbone for configuring both ENBUILD and its Catalog Items, ensuring a smooth and efficient software development and deployment process. This configuration file, named manifest.json, is stored in a GitLab or GitHub repository, aligning with version control best practices and supporting a GitOps approach.\nOverview of manifest.json The manifest file, devoid of the \u0026ldquo;.json\u0026rdquo; extension reference, organizes each Catalog Item that appears on the ENBUILD UI. It provides a structured view of the available items, facilitating easy management and customization.\n{ \u0026#34;catalogs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;file_name\u0026#34;: \u0026#34;aws_landing_zone\u0026#34; } //Additional Catalog Items... ] } ","date":"2023-09-07","id":11,"permalink":"/docs/getting-started/catalog-manifest-schema/","summary":"The ENBUILD Manifest serves as the backbone for configuring both ENBUILD and its Catalog Items, ensuring a smooth and efficient software development and deployment process.","tags":[],"title":"Catalog Manifest Schema"},{"content":"The detailed configuration for each Catalog Item resides in separate JSON files, such as \u0026ldquo;aws_landing_zone.json.\u0026rdquo; These files define crucial parameters for deployment using tools like Terraform or Helm.\nAWS Landing Zone Example: { \u0026#34;type\u0026#34;: \u0026#34;terraform\u0026#34;, \u0026#34;slug\u0026#34;: \u0026#34;aws_landing_zone\u0026#34;, // ... (other fields) \u0026#34;description\u0026#34;: \u0026#34;The Landing Zone (IL4) module deploys an AWS infrastructure following AWS recommended best practices for CMS cloud.\u0026#34;, \u0026#34;components\u0026#34;: [ // ... (list of components) ], \u0026#34;infrastructure\u0026#34;: { // ... (infrastructure details) } } This snippet showcases essential details, including the deployment type, repository information, description, and specific components.\nBig Bang Deployment Example: For more complex deployments, such as Platform One\u0026rsquo;s Big Bang, a Helm-based deployment, the manifest file (bigbang.json) orchestrates a multitude of components within a Kubernetes cluster. This exemplifies the versatility of ENBUILD in managing diverse and intricate deployment scenarios.\n{ \u0026#34;type\u0026#34;: \u0026#34;helm\u0026#34;, \u0026#34;slug\u0026#34;: \u0026#34;bigbang\u0026#34;, // ... (other fields) \u0026#34;description\u0026#34;: \u0026#34;The BigBang module deploys standard BigBang components on top of an existing Kubernetes cluster. Ver 1.50\u0026#34;, \u0026#34;components\u0026#34;: [ // ... (list of components) ], \u0026#34;infrastructure\u0026#34;: { // ... (infrastructure details) }, \u0026#34;configuration\u0026#34;: [ // ... (additional configuration details) ] } In summary, the ENBUILD Manifest plays a pivotal role in configuring and managing the diverse array of software deployments offered through the ENBUILD platform. Developers can leverage this structured approach to streamline their workflows, ensuring consistency, version control, and efficient collaboration.\nCatalog Item Manifest JSON Key Value Pairs: Name Description Example Input(s) type The type of Catalog Item terraform helm slug Slug of the Catalog Item name Name of the Catalog Item AWS Landing Zone Big Bang repository The reference URL of the template repository (what ENBUILD creates a project / repository from) https://gitlab.com/enbuild-staging/iac-templates/bigbang project_id This is specific to GitLab the project id of the repository in GitLab 202 readme_file_path The path of the README file inside the template repository. Note: This will be displayed on the ENBUILD UI when the user clicks the Information button. /docs/README.md values_folder_path The location to save the updated values secrets_folder_path The location to save the updated secrets ref The branch of the template repository to build from main sops Enable or disable Mozilla SOPS for the Catalog Item. If false the secret tab is not displayed True image_path The path of the image to display as the ENBUILD Catalog Item logo. This image needs to be available within the template project repository. /images/AKS.jpeg components What components the Catalog Item has. See Table Below infrastructure What infrastructure is required and compatible with the Catalog Item. See Table Below Component JSON Key Value Pairs: Name Description Example Input(s) type The type of Catalog Item terraform helm slug Slug of the Catalog Item name Name of the Catalog Item AWS Landing Zone Big Bang repository The reference URL of the template repository (what ENBUILD creates a project / repository from) https://gitlab.com/enbuild-staging/iac-templates/bigbang project_id This is specific to GitLab the project id of the repository in GitLab 202 readme_file_path The path of the README file inside the template repository. Note: This will be displayed on the ENBUILD UI when the user clicks the Information button. /docs/README.md values_folder_path The location to save the updated values secrets_folder_path The location to save the updated secrets ref The branch of the template repository to build from main image_path The path of the image to display as the ENBUILD Catalog Item logo. This image needs to be available within the template project repository. /images/AKS.jpeg tool_type The type of tool used to group common tools on the ENBUILD UI Security Infrastructure JSON Key Value Pairs: Name Description Example Input(s) type The type of Catalog Item terraform helm slug Slug of the Catalog Item name Name of the Infrastructure Input AWS Service Principal ID mandatory Is this input optional? true showKubeConfig ??? ??? selections ??? ??? ","date":"2023-09-07","id":12,"permalink":"/docs/getting-started/catalog-item-configuration/","summary":"The detailed configuration for each Catalog Item resides in separate JSON files, such as \u0026ldquo;aws_landing_zone.json.\u0026rdquo; These files define crucial parameters for deployment using tools like Terraform or Helm.","tags":[],"title":"Catalog Item Configuration"},{"content":"Follow these step-by-step instructions to deploy ENBUILD locally for testing.\nPrerequisites Existing Kubernetes Cluster Ensure that you have access to a Kubernetes cluster and obtain the KubeConfig file.\nYou can use rancher-desktop or k3d to spin up a local Kubernetes cluster.\nENBUILD Container Images Access to the ENBUILD container images are required for this deployment. These images are published to the VivSoft managed container reigistry on registry.gitLab.com. Make sure that you have the necessary credentials to pull these images.\nHelm CLI The Helm streamlines and automates Kubernetes deployments by managing charts, enabling users to easily package, version, and deploy complex applications.\nDeployment Steps: Following are the steps you will need to take to deploy ENBUILD to your Kubernetes cluster.\nAdd ENBUILD Helm Chart Repository To add the ENBUILD Helm chart repository, run the following command:\nhelm repo add vivsoft https://vivsoftorg.github.io/enbuild \u0026#34;vivsoft\u0026#34; has been added to your repositories Configure ENBUILD Helm Values Before deploying ENBUILD to the Kubernetes cluster, you will need to create a custom values.yaml file so that we can specify configurations unique to this deployment.\nFor local deployment however we require minimum deployment values.\n❗ Note: For more information about the complete set of ENBUILD Helm values click here!\nglobal: imageCredentials: registry: registry.gitlab.com username: MY_GITLAB_USERNAME password: MY_GITLAB_TOKEN ⚡ Note: The imageCredentials section is only required until the images are available publically.\nDeploy ENBUILD HELM Chart Make sure you update the values input to reference the values you created in Step 2. Execute the command below.\nhelm upgrade --install --namespace enbuild enbuild vivsoft/enbuild --create-namespace -f target/quick_install.yaml Release \u0026#34;enbuild\u0026#34; does not exist. Installing it now. NAME: enbuild LAST DEPLOYED: Fri Mar 22 17:37:23 2024 NAMESPACE: enbuild STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: 1. Get the application URL by running these commands: echo \u0026#34;Visit http://127.0.0.1:3000 to use your application after starting the port forward\u0026#34; kubectl --namespace enbuild port-forward svc/enbuild-enbuild-ui 3000:80 Validate ENBUILD Deployment Use the following commands to validate the ENBUILD pods are up and running.\nkubectl get pods -n enbuild NAME READY STATUS RESTARTS AGE enbuild-enbuild-genai-8488c86d6f-csfmn 1/1 Running 0 76m enbuild-enbuild-ui-56f5667d5b-4xckt 1/1 Running 0 76m enbuild-mongodb-0 1/1 Running 0 76m enbuild-rabbitmq-0 1/1 Running 0 76m enbuild-enbuild-backend-66676f8cd8-hxtbr 1/1 Running 0 76m enbuild-enbuild-user-b87d95b45-c79p6 1/1 Running 0 76m enbuild-enbuild-request-7c47c6d67b-j2fnd 1/1 Running 1 (73m ago) 76m enbuild-enbuild-ml-6f944ff759-ztdj6 1/1 Running 1 (73m ago) 76m enbuild-rabbitmq-1 1/1 Running 0 73m enbuild-rabbitmq-2 1/1 Running 0 72m enbuild-enbuild-mq-575c965764-zcnlg 1/1 Running 18 (6m24s ago) 76m ❗ Note: You might see restarts of the enbuild-enbuild-mq-* pod until the RabbitMQ service is up and running.\nValidate the ENBUILD services are setup correctly\nkubectl get services -n enbuild NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE enbuild-rabbitmq-headless ClusterIP None \u0026lt;none\u0026gt; 4369/TCP,5672/TCP,25672/TCP,15672/TCP 80s enbuild-mongo ClusterIP 10.43.230.6 \u0026lt;none\u0026gt; 27017/TCP 80s enbuild-enbuild-user ClusterIP 10.43.140.228 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-enbuild-ui ClusterIP 10.43.110.47 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-enbuild-backend ClusterIP 10.43.146.20 \u0026lt;none\u0026gt; 80/TCP 80s enbuild-rabbitmq ClusterIP 10.43.54.197 \u0026lt;none\u0026gt; 5672/TCP,4369/TCP,25672/TCP,15672/TCP 80s Access ENBUILD Use the port forwarding command to access the ENBUILD UI using your web browser.\nkubectl --namespace enbuild port-forward svc/enbuild-enbuild-ui 3000:80 Forwarding from 127.0.0.1:3000 -\u0026gt; 8080 Forwarding from [::1]:3000 -\u0026gt; 8080 Navigate your web browser to http://127.0.0.1:3000. and set the admin password.\nAfter you set the initial admin password, you should see the ENBUILD home page with BigBang Catalog.\nUninstall ENBUILD Use the following command to uninstall ENBUILD from your Kubernetes cluster.\nhelm uninstall enbuild -n enbuild release \u0026#34;enbuild\u0026#34; uninstalled ","date":"2023-09-07","id":13,"permalink":"/docs/how-to-guides/deploying-enbuild-for-local-testing/","summary":"Follow these step-by-step instructions to deploy ENBUILD locally for testing.\nPrerequisites Existing Kubernetes Cluster Ensure that you have access to a Kubernetes cluster and obtain the KubeConfig file.","tags":[],"title":"Deploying ENBUILD for Local Testing"},{"content":"GitLab Resources The following table contains groups and repositories for ENBUILD.\nName Description iac-templates All ENBUILD Catalog Item Templates are located in this Group. vivsoft-platform The vivsoft-platform repository contains the source code for ENBUILD microservices. It is the codebase for building and maintaining the various microservices that collectively form the ENBUILD platform. basewos-rhel8 The basewos-rhel8 repository includes Packer configuration for creating a Red Hat 8 hardened Amazon Machine Image (AMI). It provides the necessary settings and scripts to build a secure and minimal RHEL8 AMI for ENBUILD use. enbuild-packer-rhel8 The enbuild-packer-rhel8 repository contains Packer configuration specifically tailored for creating a minimal ENBUILD AMI. It includes the necessary configuration details for building a lightweight and optimized AMI. hardened-gitlab-runner The hardened-gitlab-runner repository provides Dockerfile configuration for building a GitLab Runner container image with enhanced security measures. It is designed to create a secure environment for CI/CD processes within the ENBUILD ecosystem. enbuild-helm-chart The enbuild-helm-chart repository contains the Helm Chart for deploying ENBUILD. It provides the necessary configurations and definitions for using Helm to deploy and manage ENBUILD components in a Kubernetes environment. GitHub Resources The following table contains groups and repositories for ENBUILD.\nHere\u0026rsquo;s your markdown table for the provided data:\nName Description VivSoftOrg VivSoftOrg is an organizational group that houses all ENBUILD Catalog Item Templates. It serves as a centralized repository for various templates related to ENBUILD. The table includes the Name as a hyperlink directing to the corresponding link and provides a description alongside it.\n","date":"2023-09-07","id":14,"permalink":"/docs/how-to-guides/enbuild-repositories/","summary":"GitLab Resources The following table contains groups and repositories for ENBUILD.\nName Description iac-templates All ENBUILD Catalog Item Templates are located in this Group.","tags":[],"title":"ENBUILD Repositories"},{"content":" ArgoCD, a declarative, GitOps continuous delivery tool for Kubernetes, revolutionizes the application deployment process. At its essence, ArgoCD enables organizations to manage and automate the deployment of applications through Git repositories, promoting a declarative approach to configuration and versioning. It continuously monitors the desired state of applications defined in Git and automatically reconciles any divergences with the current state in the Kubernetes cluster. This ensures that applications are consistently deployed and maintained across different environments. ArgoCD\u0026rsquo;s intuitive user interface provides visibility into the deployment status, allowing for easy tracking and rollbacks. With support for multiple clusters and repositories, ArgoCD empowers teams to achieve efficient, scalable, and auditable continuous delivery workflows in Kubernetes environments.\nSample ArgoCD Commands Below is a list of common ArgoCD CLI commands for managing Kubernetes applications:\nLogging in to Argo CD Server To log in to the Argo CD server, use the following command:\nargocd login \u0026lt;argocd-server-url\u0026gt; --username \u0026lt;username\u0026gt; --password \u0026lt;password\u0026gt; Setting the Current Context Before executing any Argo CD CLI commands, you need to set the current context to the Argo CD server:\nargocd context \u0026lt;argocd-server-url\u0026gt; Listing Applications List all applications managed by Argo CD:\nargocd app list Getting Information about an Application Retrieve detailed information about a specific application:\nargocd app get \u0026lt;application-name\u0026gt; Syncing an Application Manually sync an application with its target state:\nargocd app sync \u0026lt;application-name\u0026gt; Setting Sync Options You can set various sync options for an application. For example:\nargocd app set \u0026lt;application-name\u0026gt; --sync-policy \u0026lt;policy\u0026gt; Deleting an Application Delete an application from Argo CD:\nargocd app delete \u0026lt;application-name\u0026gt; Configuring Auto-Sync Enable or disable auto-sync for an application:\nargocd app auto-sync \u0026lt;application-name\u0026gt; --\u0026lt;enable/disable\u0026gt; Viewing Application Resources List Kubernetes resources managed by an application:\nargocd app resources \u0026lt;application-name\u0026gt; Accessing Argo CD Web UI You can also access the Argo CD Web UI by running:\nargocd open Logging out of Argo CD Server To log out of the Argo CD server, run:\nargocd logout Further Reading Read argocd Official Documentation ","date":"2023-09-07","id":15,"permalink":"/docs/references/argocd/","summary":"ArgoCD, a declarative, GitOps continuous delivery tool for Kubernetes, revolutionizes the application deployment process. At its essence, ArgoCD enables organizations to manage and automate the deployment of applications through Git repositories, promoting a declarative approach to configuration and versioning.","tags":[],"title":"ArgoCD"},{"content":" About Q: Who is behind this project?\nA: VivSoft! 🐘 VivSoft is focused on solving complex problems in the public sector using innovative technologies. VivSoft is working with business leaders in federal, state and local government to help mission owners accelerate innovation using DevSecOps, Cloud, AI/ML and Blockchain Technologies.\nQ: What problem does ENBUILD solve?\nA: ENBUILD\u0026rsquo;s goal is to empower organizations to leverage Kubernetes and cloud-native technologies effectively while minimizing the complexity and overhead associated with deployment and management tasks. By offering pre-configured catalog items and promoting best practices, ENBUILD enables organizations to streamline their development workflows, reduce time to market, and achieve their product development goals more efficiently.\nCosts and Licensing Fees Q: Is ENBUILD free to use?\nA: Yes, ENBUILD is free to use.\nQ: What license does ENBUILD use?\nA: ENBUILD utilizes the Apache License, which is an open-source software license recognized for its flexibility and permissive nature. This license allows users to freely use, modify, and distribute the software, whether for personal, commercial, or open-source projects. For more detailed information about the Apache License and its implications, please refer to the official Apache Software Foundation website or consult the license file included with the ENBUILD software distribution.\nSecurity Q: What dependencies does ENBUILD have?\nA: ENBUILD, being a Kubernetes native application, relies on certain dependencies to function optimally. These dependencies include:\nKubernetes Cluster: ENBUILD requires a Kubernetes cluster to operate. This ensures that ENBUILD can leverage the scalability, resilience, and orchestration capabilities provided by Kubernetes, thereby enabling efficient deployment and management of containerized applications. Version Control System (VCS) for ENBUILD Catalog Item Deployments: ENBUILD utilizes a Version Control System for managing and deploying ENBUILD Catalog Items. Currently, ENBUILD supports integration with two popular VCS platforms:\nGitLab: ENBUILD seamlessly integrates with GitLab, allowing users to leverage the robust features of GitLab for managing and versioning their ENBUILD Catalog Items. This includes support for both the Software as a Service (SaaS) offering of GitLab and self-hosted deployments of GitLab instances.\nGitHub: ENBUILD also supports integration with GitHub, enabling users to utilize GitHub\u0026rsquo;s collaborative features and version control capabilities for ENBUILD Catalog Item deployments. Similar to GitLab, ENBUILD supports both the SaaS offering of GitHub and self-hosted deployments of GitHub Enterprise instances.\nBy supporting these Version Control Systems, ENBUILD provides users with flexibility and choice, allowing them to seamlessly integrate ENBUILD into their existing development workflows while leveraging the capabilities of their preferred VCS platform.\nFor further details on setting up ENBUILD dependencies and integration with specific Version Control Systems, please refer to the ENBUILD documentation or reach out to our support team for assistance.\nDeployment Q: What types of Kubernetes distributions is ENBUILD compatible with?\nA: ENBUILD has been deployed and tested on the following distributions of Kubernetes:\nAmazon EKS (Elastic Kubernetes Service): ENBUILD is fully compatible with Amazon EKS, allowing users to deploy and manage ENBUILD on Amazon Web Services\u0026rsquo; managed Kubernetes service. Azure AKS (Azure Kubernetes Service): ENBUILD seamlessly integrates with Azure AKS, enabling users to deploy and run ENBUILD on Microsoft Azure\u0026rsquo;s managed Kubernetes service. Rancher K3D: ENBUILD supports deployment on Rancher K3D, a lightweight Kubernetes distribution designed for local development and testing purposes. Rancher RKE2: ENBUILD is compatible with Rancher RKE2, an enterprise-grade Kubernetes distribution optimized for production workloads. Configuration Q: What is an ENBUILD Catalog Item (CI)?\nA: An ENBUILD Catalog Item, often abbreviated as CI, serves as a standardized template project designed to streamline the deployment and management of various infrastructure components and applications within the ENBUILD ecosystem. These Catalog Items are meticulously crafted by developers to encapsulate pre-configured settings, best practices, and reusable components, providing users with a simplified and consistent approach to deploying complex infrastructure and applications.\nENBUILD Catalog Items are tailored to support a diverse range of use cases and technologies, including:\nTerraform Infrastructure as Code (IaC): Catalog Items for Terraform enable users to define and manage cloud infrastructure resources using Infrastructure as Code principles. These Catalog Items offer pre-defined templates and configurations for provisioning resources on popular cloud platforms such as AWS, Azure, and Google Cloud Platform, facilitating rapid deployment and automation of infrastructure provisioning tasks.\nKubernetes Distributions (e.g., Amazon EKS, Azure AKS): Catalog Items for Kubernetes distributions provide users with pre-configured templates for deploying and managing Kubernetes clusters on various cloud providers, such as Amazon EKS (Elastic Kubernetes Service) and Azure AKS (Azure Kubernetes Service). These Catalog Items simplify the setup and configuration of Kubernetes clusters, enabling users to leverage the scalability and agility of Kubernetes for containerized application deployment and orchestration.\nHelm Deployments (e.g., Big Bang): Catalog Items for Helm deployments offer pre-packaged configurations and charts for deploying applications and services using Helm, a popular package manager for Kubernetes. These Catalog Items streamline the deployment of complex applications by providing ready-to-use Helm charts and configurations, reducing the time and effort required for setting up and configuring application environments.\nBy leveraging ENBUILD Catalog Items, developers gain access to a curated library of templates and configurations that serve as starting points for their projects. These Catalog Items not only accelerate the development and deployment process but also promote consistency, reliability, and best practices across projects within the ENBUILD ecosystem.\nQ: What is an ENBUILD Version Control System (VCS)?\nA: A Version Control System (VCS) is a fundamental tool used in software development to manage and track changes to source code, configuration files, and other project assets over time. It allows multiple developers to collaborate on a project concurrently while maintaining a history of all modifications made to the project files.\nIn the context of ENBUILD, a Version Control System (VCS) plays a crucial role in managing and deploying ENBUILD Catalog Items, which are template projects designed to facilitate the deployment of infrastructure components and applications within the ENBUILD ecosystem. ENBUILD supports integration with popular VCS platforms such as GitLab and GitHub, providing users with the flexibility to version control their Catalog Items and streamline the deployment process.\nKey features and benefits of using a Version Control System (VCS) include:\nHistory Tracking: VCS systems maintain a detailed history of changes made to project files, including who made the changes and when they were made. This allows developers to review past revisions, track the evolution of the project, and revert to previous versions if necessary.\nCollaboration: VCS systems enable seamless collaboration among team members by providing mechanisms for sharing and synchronizing changes to project files. Multiple developers can work on the same codebase simultaneously without risking conflicts or data loss.\nBranching and Merging: VCS systems support branching and merging workflows, allowing developers to create separate branches to work on specific features or fixes independently. Branches can later be merged back into the main codebase, ensuring a streamlined and organized development process.\nAuditing and Compliance: VCS systems offer auditing capabilities that help maintain compliance with regulatory requirements and internal policies. Organizations can track and monitor all changes made to project files, ensuring accountability and transparency in the development process.\nBy leveraging a Version Control System (VCS) such as GitLab or GitHub, ENBUILD users can effectively manage their Catalog Items, collaborate with team members, track changes, and maintain a consistent and reliable deployment workflow.\nChange Control Q: What is the Release schedule?\nA: To Be Determined. 📆\n","date":"2023-09-07","id":16,"permalink":"/docs/faq/frequently-asked-questions/","summary":"About Q: Who is behind this project?\nA: VivSoft! 🐘 VivSoft is focused on solving complex problems in the public sector using innovative technologies.","tags":[],"title":"Frequently Asked Questions"},{"content":" GitLab stands as a comprehensive DevOps platform, providing end-to-end solutions for source code management, continuous integration, delivery, security, and more. As an integrated tool, GitLab facilitates collaboration among development, operations, and security teams, streamlining the entire software development lifecycle. With its version control capabilities based on Git, GitLab allows teams to efficiently manage and track changes in their codebase. Beyond version control, GitLab\u0026rsquo;s robust CI/CD pipelines automate the building, testing, and deployment of applications, ensuring rapid and reliable delivery. The platform also emphasizes security with built-in features for code scanning, vulnerability management, and compliance tracking. GitLab\u0026rsquo;s all-in-one approach fosters collaboration, transparency, and efficiency, making it a preferred choice for organizations aiming to achieve seamless and integrated DevOps workflows.\nFurther Reading Read gitlab Official Documentation ","date":"2023-09-07","id":17,"permalink":"/docs/references/gitlab/","summary":"GitLab stands as a comprehensive DevOps platform, providing end-to-end solutions for source code management, continuous integration, delivery, security, and more.","tags":[],"title":"GitLab"},{"content":" The Helm CLI serves as a powerful package manager for Kubernetes applications, streamlining and simplifying the deployment and management of complex containerized applications. At its core, Helm utilizes charts—pre-configured packages of Kubernetes resources—to encapsulate and version entire applications. With the Helm CLI, users can effortlessly install, upgrade, and roll back applications, ensuring consistent and reproducible deployments across different environments. Its templating system allows for easy customization of configurations, while the Helm repository facilitates the sharing and distribution of charts. Whether orchestrating microservices or deploying scalable applications, Helm proves to be an indispensable tool for developers and operators seeking efficiency and consistency in Kubernetes environments. Sample Helm Commands Below is a list of common Helm CLI commands for managing Kubernetes applications:\nInitializing Helm Initialize Helm in your Kubernetes cluster:\nhelm init Adding a Helm Repository Add a repository containing Helm Charts:\nhelm repo add stable https://charts.helm.sh/stable Searching for Helm Charts Searching for Helm charts in the added repositories:\nhelm search repo \u0026lt;keyword\u0026gt; Installing a Helm Chart Install a Helm chart into your Kubernetes cluster:\nhelm install \u0026lt;release-name\u0026gt; \u0026lt;chart-name\u0026gt; Listing Installed Helm Releases List all installed Helm releases:\nhelm list Getting Information about a Release Get information about a specific Helm release:\nhelm status \u0026lt;release-name\u0026gt; Upgrading a Helm Release Upgrade a Helm release to a new version:\nhelm upgrade \u0026lt;release-name\u0026gt; \u0026lt;chart-name\u0026gt; Deleting a Helm Release Delete a Helm release from your Kubernetes cluster:\nhelm delete \u0026lt;release-name\u0026gt; Viewing Helm Release History View the history of changes for a Helm release:\nhelm history \u0026lt;release-name\u0026gt; Uninstalling Helm To uninstall Helm from your Kubernetes cluster, run:\nhelm reset Further Reading Read helm Official Documentation ","date":"2023-09-07","id":18,"permalink":"/docs/references/helm/","summary":"The Helm CLI serves as a powerful package manager for Kubernetes applications, streamlining and simplifying the deployment and management of complex containerized applications.","tags":[],"title":"Helm"},{"content":" Istio, a robust and open-source service mesh platform, redefines how microservices communicate within a Kubernetes environment. Acting as a dedicated layer for managing and securing microservice interactions, Istio provides a comprehensive set of tools for traffic management, load balancing, and observability. By intelligently routing and controlling the flow of traffic between services, Istio enhances resilience, fault tolerance, and overall service reliability. Its built-in security features, such as mutual TLS authentication and access control, fortify communication channels between microservices. Additionally, Istio\u0026rsquo;s observability capabilities, including distributed tracing and metrics collection, offer insights into application performance. With Istio, organizations can effortlessly implement a resilient and secure microservices architecture, ultimately improving the manageability and reliability of their containerized applications. Sample Istio Commands Below is a list of common Istio CLI commands for managing Istio service mesh:\nInstalling Istio Install Istio into your Kubernetes cluster:\nistioctl install Verifying Istio Installation Verify that Istio components are installed correctly:\nistioctl verify-install Listing Istio Virtual Services List all Istio Virtual Services in the cluster:\nistioctl get virtualservices Creating a Virtual Service Create a new Istio Virtual Service:\nistioctl create -f virtual-service.yaml Updating a Virtual Service Update an existing Istio Virtual Service:\nistioctl replace -f virtual-service.yaml Deleting a Virtual Service Delete an Istio Virtual Service:\nistioctl delete virtualservice \u0026lt;virtual-service-name\u0026gt; Listing Istio Gateways List all Istio Gateways in the cluster:\nistioctl get gateways Viewing Istio Service Mesh Dashboard Access the Istio Service Mesh dashboard:\nistioctl dashboard kiali Generating Istio Service Graph Generate a service graph for Istio services:\nistioctl analyze Viewing Istio Proxy Logs View logs from Istio proxies:\nistioctl proxy-config log \u0026lt;pod-name\u0026gt; Upgrading Istio Upgrade Istio to a newer version:\nistioctl upgrade -f istio-upgrade.yaml Uninstalling Istio Uninstall Istio from your Kubernetes cluster:\nistioctl x uninstall --purge Further Reading Read istio Official Documentation ","date":"2023-09-07","id":19,"permalink":"/docs/references/istio/","summary":"Istio, a robust and open-source service mesh platform, redefines how microservices communicate within a Kubernetes environment. Acting as a dedicated layer for managing and securing microservice interactions, Istio provides a comprehensive set of tools for traffic management, load balancing, and observability.","tags":[],"title":"Istio"},{"content":" K3D, a lightweight and versatile tool, simplifies the management and deployment of Kubernetes clusters by bringing the power of Kubernetes into a single-node environment. Designed for simplicity and speed, K3D allows developers and operators to spin up Kubernetes clusters with ease, making it an ideal choice for local development, testing, and CI/CD pipelines. Leveraging containerd and other containerization technologies, K3D offers a minimalistic yet efficient Kubernetes experience. Users can create, scale, and delete clusters effortlessly, making it a valuable tool for scenarios where resource constraints or rapid cluster provisioning are crucial. With K3D, developers can focus on building and testing applications in a Kubernetes-like environment without the complexity of managing large-scale clusters, thereby accelerating the development lifecycle.\nSample K3D Commands Below is a list of basic K3D CLI commands for managing Kubernetes clusters:\nCreating a Kubernetes Cluster Create a new Kubernetes cluster using k3d:\nk3d cluster create \u0026lt;cluster-name\u0026gt; Listing Kubernetes Clusters List all existing Kubernetes clusters managed by k3d:\nk3d cluster list Getting Information about a Cluster Retrieve detailed information about a specific Kubernetes cluster:\nk3d cluster get \u0026lt;cluster-name\u0026gt; Accessing Kubernetes Cluster Set the kubeconfig context to the newly created Kubernetes cluster:\nexport KUBECONFIG=\u0026#34;$(k3d kubeconfig write \u0026lt;cluster-name\u0026gt;)\u0026#34; Deleting a Kubernetes Cluster Delete a Kubernetes cluster managed by k3d:\nk3d cluster delete \u0026lt;cluster-name\u0026gt; Starting a Kubernetes Cluster Start a previously stopped Kubernetes cluster:\nk3d cluster start \u0026lt;cluster-name\u0026gt; Stopping a Kubernetes Cluster Stop a running Kubernetes cluster:\nk3d cluster stop \u0026lt;cluster-name\u0026gt; Scaling Nodes Scale the number of worker nodes in the cluster:\nk3d node create \u0026lt;node-name\u0026gt; --replicas \u0026lt;num-replicas\u0026gt; Exporting kubeconfig Export the kubeconfig file for a cluster:\nk3d kubeconfig write \u0026lt;cluster-name\u0026gt; Further Reading Read k3d Official Documentation ","date":"2023-09-07","id":20,"permalink":"/docs/references/k3d/","summary":"K3D, a lightweight and versatile tool, simplifies the management and deployment of Kubernetes clusters by bringing the power of Kubernetes into a single-node environment.","tags":[],"title":"K3D"},{"content":" Big Bang is a declarative, continuous delivery tool for deploying DoD hardened and approved packages into a Kubernetes cluster.\nUsage \u0026amp; Scope Big Bang\u0026rsquo;s scope is to provide publicly available installation manifests for packages required to adhere to the DoD DevSecOps Reference Architecture and additional useful utilities. Big Bang packages are broken into three categories:\nCore: Core packages are a group of capabilities required by the DoD DevSecOps Reference Architecture, that are supported directly by the Big Bang development team. The specific capabilities that are considered core currently are Service Mesh, Policy Enforcement, Logging, Monitoring, and Runtime Security.\nAddons: Addon packages are any packages/capabilities that the Big Bang development team directly supports that do not fall under the above core definition. These serve to extend the functionality/features of Big Bang.\nCommunity: Community packages are any packages that are maintained by the broader Big Bang community (users, vendors, etc). These packages could be alternatives to core or addon packages, or even entirely new packages to help extend usage/functionality of Big Bang.\nIn order for an installation of Big Bang to be a valid installation/configuration you must install/deploy a core package of each category (for additional details on categories and options see here).\nBig Bang also builds tooling around the testing and validation of Big Bang packages. These tools are provided as-is, without support.\nBig Bang is intended to be used for deploying and maintaining a DoD hardened and approved set of packages into a Kubernetes cluster. Deployment and configuration of ingress/egress, load balancing, policy auditing, logging, monitoring, etc. are handled via Big Bang. Additional packages (e.g. ArgoCD, GitLab) can also be enabled and customized to extend Big Bang\u0026rsquo;s baseline. Once deployed, the Kubernetes cluster can be used to add mission specific applications.\nFurther Reading Read big bang Official Documentation Checkout big bang on GitHub ","date":"2023-09-07","id":21,"permalink":"/docs/references/platform-one-big-bang/","summary":"Big Bang is a declarative, continuous delivery tool for deploying DoD hardened and approved packages into a Kubernetes cluster.","tags":[],"title":"Platform One Big Bang"},{"content":"","date":"2023-09-07","id":22,"permalink":"/","summary":"","tags":[],"title":"ENBUILD"},{"content":"","date":"0001-01-01","id":23,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":24,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":25,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]